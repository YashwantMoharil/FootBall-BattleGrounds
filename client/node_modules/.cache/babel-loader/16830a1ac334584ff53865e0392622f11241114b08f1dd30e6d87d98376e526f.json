{"ast":null,"code":"var _jsxFileName = \"/Users/yashwantmoharil/Desktop/football-battlegrounds/client/src/Components/TicTacToe.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState } from \"react\";\nimport { useChannelStateContext, useChatContext } from \"stream-chat-react\";\nimport Board from \"./Board\";\nimport GameOver from \"./GameOver\";\nimport GameState from \"./GameState\";\nimport Reset from \"./Reset\";\nimport Mines from \"./Mines\"; // Assuming Mines is a function that returns the mine array\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction TicTacToe() {\n  _s();\n  const player = \"X\"; // This is likely for the local UI display; actual player is client.userID\n  const [turn, setTurn] = useState(\"X\");\n  const [mistakeCounts, setMistakeCounts] = useState({\n    \"X\": 0,\n    \"O\": 0\n  });\n  const {\n    channel\n  } = useChannelStateContext();\n  const {\n    client\n  } = useChatContext();\n  const [tiles, setTiles] = useState(Array(64).fill(null));\n  const [mines, setMines] = useState(Array(64).fill(null));\n  const [mineCount, setMineCount] = useState(5);\n  const [strike, setStrike] = useState(null);\n  const [gameState, setGameState] = useState(GameState.mineCreation);\n  console.log(\"--- Component Render ---\");\n  console.log(\"Current State on Render:\", {\n    turn,\n    mistakeCounts,\n    mineCount,\n    gameState,\n    tiles: tiles.slice(0, 5),\n    mines: mines.slice(0, 5)\n  }); // Log partial tiles/mines for brevity\n\n  // Effect for initial mine creation (runs once when component mounts and state matches)\n  useEffect(() => {\n    console.log(\"useEffect [gameState] triggered for mine creation. Current gameState:\", gameState);\n    if (gameState === GameState.mineCreation) {\n      console.log(\"Generating new mines...\");\n      const newGrid = Mines(mineCount);\n      setMines(newGrid);\n      setGameState(GameState.start);\n      console.log(\"Mines generated and gameState set to GameState.start\");\n    }\n  }, [gameState, mineCount]); // Depend on gameState and mineCount\n\n  const handleTileclick = async index => {\n    console.log(`handleTileclick: Tile ${index} clicked by local client.`);\n    console.log(\"Current gameState:\", gameState);\n    console.log(\"Current tiles[index]:\", tiles[index]);\n    if (gameState !== GameState.start && gameState !== GameState.inProgress) {\n      console.log(\"Click ignored: Game not in playable state.\");\n      return;\n    }\n    if (tiles[index] !== null) {\n      console.log(\"Click ignored: Tile already revealed.\");\n      return;\n    }\n\n    // Capture current state values *before* modifications for calculations\n    const currentTurn = turn;\n    const currentMistakeCounts = {\n      ...mistakeCounts\n    };\n    const currentMineCount = mineCount;\n\n    // --- Calculate new state based on the click ---\n    const newTiles = [...tiles];\n    const isMine = mines[index] === -1; // Check if it's a mine\n    newTiles[index] = mines[index]; // Reveal the tile\n\n    let updatedMineCount = currentMineCount;\n    const updatedMistakeCounts = {\n      ...currentMistakeCounts\n    };\n    let updatedGameState = gameState === GameState.start ? GameState.inProgress : gameState; // Progress game state if starting\n    let nextTurn = currentTurn === 'X' ? 'O' : 'X';\n    if (isMine) {\n      console.log(`Tile ${index} is a mine!`);\n      updatedMineCount -= 1;\n      updatedMistakeCounts[currentTurn] = (updatedMistakeCounts[currentTurn] || 0) + 1; // Increment mistake for current player\n\n      if (updatedMineCount === 0) {\n        updatedGameState = GameState.gameover; // All mines found (or exploded)\n        console.log(\"All mines found, game over!\");\n      }\n    }\n\n    // --- Update local state immediately for instant UI feedback ---\n    console.log(\"Updating local state...\");\n    setTiles(newTiles);\n    setMineCount(updatedMineCount);\n    setMistakeCounts(updatedMistakeCounts);\n    setTurn(nextTurn);\n    setGameState(updatedGameState);\n    console.log(\"Local state updated. New values (not yet reflected in closure):\", {\n      newTiles: newTiles.slice(0, 5),\n      // Partial for logging\n      updatedMineCount,\n      updatedMistakeCounts,\n      nextTurn,\n      updatedGameState\n    });\n\n    // --- Send the *calculated and updated* state to other clients ---\n    console.log(\"Sending game_move event...\");\n    await channel.sendEvent({\n      type: \"game_move\",\n      // Using snake_case for consistency with common practices\n      data: {\n        tiles: newTiles,\n        // Send the newly calculated tiles array\n        mines: mines,\n        // Mines layout should be consistent, so current is fine\n        mineCount: updatedMineCount,\n        // Send the calculated updated mine count\n        mistakeCounts: updatedMistakeCounts,\n        // Send the calculated updated mistake counts\n        turn: nextTurn,\n        // Send the calculated next turn\n        gameState: updatedGameState // Send the calculated updated game state\n      }\n    });\n    console.log(\"game_move event sent successfully.\");\n  };\n\n  // Effect for receiving game events from other clients\n  useEffect(() => {\n    const handleGameEvent = event => {\n      console.log(\"Incoming event detected:\", event.type, \"from user:\", event.user.id);\n      console.log(\"Current client.userID:\", client.userID);\n\n      // Important: Only process events that are not from the current client\n      if (event.type === \"game_move\" && event.user.id !== client.userID) {\n        console.log(\"Received game_move from remote user. Applying synced state.\");\n        console.log(\"Remote data:\", event.data);\n        setTiles(event.data.tiles);\n        setMines(event.data.mines); // Important for mine positions\n        setMineCount(event.data.mineCount);\n        setMistakeCounts(event.data.mistakeCounts);\n        setTurn(event.data.turn);\n        setGameState(event.data.gameState);\n        console.log(\"Remote state applied.\");\n      }\n      // Handle reset events\n      if (event.type === \"game_reset\" && event.user.id !== client.userID) {\n        console.log(\"Received game_reset from remote user. Applying synced state.\");\n        console.log(\"Remote reset data:\", event.data);\n        setTiles(event.data.tiles);\n        setMines(event.data.mines);\n        setMineCount(event.data.mineCount);\n        setMistakeCounts(event.data.mistakeCounts);\n        setTurn(event.data.turn);\n        setGameState(event.data.gameState);\n        setStrike(event.data.strike);\n        console.log(\"Remote reset state applied.\");\n      }\n    };\n\n    // Register the event listener\n    console.log(\"Attaching channel event listener.\");\n    channel.on(\"event\", handleGameEvent);\n\n    // Cleanup function: Unregister the event listener when the component unmounts\n    return () => {\n      console.log(\"Detaching channel event listener.\");\n      channel.off(\"event\", handleGameEvent);\n    };\n  }, [channel, client.userID]); // Dependencies for useEffect\n\n  const handleReset = async () => {\n    console.log(\"handleReset initiated by local client.\");\n    const initialTiles = Array(64).fill(null);\n    const newMinesLayout = Mines(5); // Regenerate mines for a fresh start\n    const initialMistakeCounts = {\n      \"X\": 0,\n      \"O\": 0\n    };\n    const initialMineCount = 5;\n\n    // Update local state first\n    console.log(\"Updating local state for reset.\");\n    setTiles(initialTiles);\n    setMines(newMinesLayout);\n    setTurn(\"X\");\n    setMistakeCounts(initialMistakeCounts);\n    setMineCount(initialMineCount);\n    setGameState(GameState.mineCreation); // Go back to mine creation state on reset\n    setStrike(null);\n    console.log(\"Local state reset.\");\n\n    // Send reset event to other clients\n    console.log(\"Sending game_reset event...\");\n    await channel.sendEvent({\n      type: \"game_reset\",\n      data: {\n        tiles: initialTiles,\n        mines: newMinesLayout,\n        turn: \"X\",\n        mineCount: initialMineCount,\n        mistakeCounts: initialMistakeCounts,\n        gameState: GameState.mineCreation,\n        strike: null\n      }\n    });\n    console.log(\"game_reset event sent successfully.\");\n  };\n\n  // Check for game winner/end conditions (Minesweeper logic)\n  useEffect(() => {\n    console.log(\"useEffect [tiles, mines, gameState] triggered for win/loss check.\");\n    const allNonMineTiles = mines.filter(m => m !== -1).length;\n    const revealedNonMineTiles = tiles.filter((t, i) => t !== null && mines[i] !== -1).length;\n    if (gameState === GameState.inProgress && revealedNonMineTiles === allNonMineTiles) {\n      setGameState(GameState.gameover); // Or GameState.win\n      console.log(\"Game Over: All non-mine tiles revealed!\");\n    }\n    // MineCount === 0 is already handled in handleTileclick for gameover.\n\n    // If you need a \"tie\" condition for a game like Tic-Tac-Toe,\n    // you'd typically check if all non-mine tiles are revealed AND there are no remaining mines,\n    // and no one \"won\" by finding all mines first. Your current `checkWinner` logic is Tic-Tac-Toe specific.\n    // If it's a Minesweeper game, a \"tie\" might not be a primary end state.\n  }, [tiles, mines, gameState]); // Dependencies for checking win condition\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Minesweeper / Tic Tac Toe Hybrid\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 208,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"h4\", {\n      children: [\"Current Turn: \", turn, \" (Your client: \", client.userID, \")\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 209,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"h4\", {\n      children: [\"Mistakes - X: \", mistakeCounts[\"X\"], \", O: \", mistakeCounts[\"O\"]]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 210,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"h4\", {\n      children: [\"Mines Remaining: \", mineCount]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 211,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Board, {\n      player: player // This 'player' is still hardcoded \"X\"\n      ,\n      tiles: tiles,\n      onTileClick: handleTileclick,\n      strike: strike\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 212,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(GameOver, {\n      gameState: gameState\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 218,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Reset, {\n      gameState: gameState,\n      onReset: handleReset\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 219,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 207,\n    columnNumber: 5\n  }, this);\n}\n_s(TicTacToe, \"xpEZw/1C6ECydXM/lQ214p9WrxM=\", false, function () {\n  return [useChannelStateContext, useChatContext];\n});\n_c = TicTacToe;\nexport default TicTacToe;\nvar _c;\n$RefreshReg$(_c, \"TicTacToe\");","map":{"version":3,"names":["React","useEffect","useState","useChannelStateContext","useChatContext","Board","GameOver","GameState","Reset","Mines","jsxDEV","_jsxDEV","TicTacToe","_s","player","turn","setTurn","mistakeCounts","setMistakeCounts","channel","client","tiles","setTiles","Array","fill","mines","setMines","mineCount","setMineCount","strike","setStrike","gameState","setGameState","mineCreation","console","log","slice","newGrid","start","handleTileclick","index","inProgress","currentTurn","currentMistakeCounts","currentMineCount","newTiles","isMine","updatedMineCount","updatedMistakeCounts","updatedGameState","nextTurn","gameover","sendEvent","type","data","handleGameEvent","event","user","id","userID","on","off","handleReset","initialTiles","newMinesLayout","initialMistakeCounts","initialMineCount","allNonMineTiles","filter","m","length","revealedNonMineTiles","t","i","children","fileName","_jsxFileName","lineNumber","columnNumber","onTileClick","onReset","_c","$RefreshReg$"],"sources":["/Users/yashwantmoharil/Desktop/football-battlegrounds/client/src/Components/TicTacToe.jsx"],"sourcesContent":["import React, { useEffect, useState } from \"react\";\nimport { useChannelStateContext, useChatContext } from \"stream-chat-react\";\nimport Board from \"./Board\";\nimport GameOver from \"./GameOver\";\nimport GameState from \"./GameState\";\nimport Reset from \"./Reset\";\nimport Mines from \"./Mines\"; // Assuming Mines is a function that returns the mine array\n\nfunction TicTacToe() {\n  const player = \"X\"; // This is likely for the local UI display; actual player is client.userID\n  const [turn, setTurn] = useState(\"X\");\n  const [mistakeCounts, setMistakeCounts] = useState({ \"X\": 0, \"O\": 0 });\n  const { channel } = useChannelStateContext();\n  const { client } = useChatContext();\n  const [tiles, setTiles] = useState(Array(64).fill(null));\n  const [mines, setMines] = useState(Array(64).fill(null));\n  const [mineCount, setMineCount] = useState(5);\n  const [strike, setStrike] = useState(null);\n  const [gameState, setGameState] = useState(GameState.mineCreation);\n\n  console.log(\"--- Component Render ---\");\n  console.log(\"Current State on Render:\", { turn, mistakeCounts, mineCount, gameState, tiles: tiles.slice(0, 5), mines: mines.slice(0, 5) }); // Log partial tiles/mines for brevity\n\n  // Effect for initial mine creation (runs once when component mounts and state matches)\n  useEffect(() => {\n    console.log(\"useEffect [gameState] triggered for mine creation. Current gameState:\", gameState);\n    if (gameState === GameState.mineCreation) {\n      console.log(\"Generating new mines...\");\n      const newGrid = Mines(mineCount);\n      setMines(newGrid);\n      setGameState(GameState.start);\n      console.log(\"Mines generated and gameState set to GameState.start\");\n    }\n  }, [gameState, mineCount]); // Depend on gameState and mineCount\n\n  const handleTileclick = async (index) => {\n    console.log(`handleTileclick: Tile ${index} clicked by local client.`);\n    console.log(\"Current gameState:\", gameState);\n    console.log(\"Current tiles[index]:\", tiles[index]);\n\n    if (gameState !== GameState.start && gameState !== GameState.inProgress) {\n      console.log(\"Click ignored: Game not in playable state.\");\n      return;\n    }\n    if (tiles[index] !== null) {\n      console.log(\"Click ignored: Tile already revealed.\");\n      return;\n    }\n\n    // Capture current state values *before* modifications for calculations\n    const currentTurn = turn;\n    const currentMistakeCounts = { ...mistakeCounts };\n    const currentMineCount = mineCount;\n\n    // --- Calculate new state based on the click ---\n    const newTiles = [...tiles];\n    const isMine = mines[index] === -1; // Check if it's a mine\n    newTiles[index] = mines[index]; // Reveal the tile\n\n    let updatedMineCount = currentMineCount;\n    const updatedMistakeCounts = { ...currentMistakeCounts };\n    let updatedGameState = gameState === GameState.start ? GameState.inProgress : gameState; // Progress game state if starting\n    let nextTurn = currentTurn === 'X' ? 'O' : 'X';\n\n    if (isMine) {\n      console.log(`Tile ${index} is a mine!`);\n      updatedMineCount -= 1;\n      updatedMistakeCounts[currentTurn] = (updatedMistakeCounts[currentTurn] || 0) + 1; // Increment mistake for current player\n\n      if (updatedMineCount === 0) {\n        updatedGameState = GameState.gameover; // All mines found (or exploded)\n        console.log(\"All mines found, game over!\");\n      }\n    }\n\n    // --- Update local state immediately for instant UI feedback ---\n    console.log(\"Updating local state...\");\n    setTiles(newTiles);\n    setMineCount(updatedMineCount);\n    setMistakeCounts(updatedMistakeCounts);\n    setTurn(nextTurn);\n    setGameState(updatedGameState);\n    console.log(\"Local state updated. New values (not yet reflected in closure):\", {\n      newTiles: newTiles.slice(0, 5), // Partial for logging\n      updatedMineCount,\n      updatedMistakeCounts,\n      nextTurn,\n      updatedGameState\n    });\n\n\n    // --- Send the *calculated and updated* state to other clients ---\n    console.log(\"Sending game_move event...\");\n    await channel.sendEvent({\n      type: \"game_move\", // Using snake_case for consistency with common practices\n      data: {\n        tiles: newTiles, // Send the newly calculated tiles array\n        mines: mines, // Mines layout should be consistent, so current is fine\n        mineCount: updatedMineCount, // Send the calculated updated mine count\n        mistakeCounts: updatedMistakeCounts, // Send the calculated updated mistake counts\n        turn: nextTurn, // Send the calculated next turn\n        gameState: updatedGameState, // Send the calculated updated game state\n      },\n    });\n    console.log(\"game_move event sent successfully.\");\n  };\n\n  // Effect for receiving game events from other clients\n  useEffect(() => {\n    const handleGameEvent = (event) => {\n      console.log(\"Incoming event detected:\", event.type, \"from user:\", event.user.id);\n      console.log(\"Current client.userID:\", client.userID);\n\n      // Important: Only process events that are not from the current client\n      if (event.type === \"game_move\" && event.user.id !== client.userID) {\n        console.log(\"Received game_move from remote user. Applying synced state.\");\n        console.log(\"Remote data:\", event.data);\n        setTiles(event.data.tiles);\n        setMines(event.data.mines); // Important for mine positions\n        setMineCount(event.data.mineCount);\n        setMistakeCounts(event.data.mistakeCounts);\n        setTurn(event.data.turn);\n        setGameState(event.data.gameState);\n        console.log(\"Remote state applied.\");\n      }\n      // Handle reset events\n      if (event.type === \"game_reset\" && event.user.id !== client.userID) {\n        console.log(\"Received game_reset from remote user. Applying synced state.\");\n        console.log(\"Remote reset data:\", event.data);\n        setTiles(event.data.tiles);\n        setMines(event.data.mines);\n        setMineCount(event.data.mineCount);\n        setMistakeCounts(event.data.mistakeCounts);\n        setTurn(event.data.turn);\n        setGameState(event.data.gameState);\n        setStrike(event.data.strike);\n        console.log(\"Remote reset state applied.\");\n      }\n    };\n\n    // Register the event listener\n    console.log(\"Attaching channel event listener.\");\n    channel.on(\"event\", handleGameEvent);\n\n    // Cleanup function: Unregister the event listener when the component unmounts\n    return () => {\n      console.log(\"Detaching channel event listener.\");\n      channel.off(\"event\", handleGameEvent);\n    };\n  }, [channel, client.userID]); // Dependencies for useEffect\n\n  const handleReset = async () => {\n    console.log(\"handleReset initiated by local client.\");\n    const initialTiles = Array(64).fill(null);\n    const newMinesLayout = Mines(5); // Regenerate mines for a fresh start\n    const initialMistakeCounts = { \"X\": 0, \"O\": 0 };\n    const initialMineCount = 5;\n\n    // Update local state first\n    console.log(\"Updating local state for reset.\");\n    setTiles(initialTiles);\n    setMines(newMinesLayout);\n    setTurn(\"X\");\n    setMistakeCounts(initialMistakeCounts);\n    setMineCount(initialMineCount);\n    setGameState(GameState.mineCreation); // Go back to mine creation state on reset\n    setStrike(null);\n    console.log(\"Local state reset.\");\n\n    // Send reset event to other clients\n    console.log(\"Sending game_reset event...\");\n    await channel.sendEvent({\n      type: \"game_reset\",\n      data: {\n        tiles: initialTiles,\n        mines: newMinesLayout,\n        turn: \"X\",\n        mineCount: initialMineCount,\n        mistakeCounts: initialMistakeCounts,\n        gameState: GameState.mineCreation,\n        strike: null,\n      },\n    });\n    console.log(\"game_reset event sent successfully.\");\n  };\n\n  // Check for game winner/end conditions (Minesweeper logic)\n  useEffect(() => {\n    console.log(\"useEffect [tiles, mines, gameState] triggered for win/loss check.\");\n    const allNonMineTiles = mines.filter(m => m !== -1).length;\n    const revealedNonMineTiles = tiles.filter((t, i) => t !== null && mines[i] !== -1).length;\n\n    if (gameState === GameState.inProgress && revealedNonMineTiles === allNonMineTiles) {\n      setGameState(GameState.gameover); // Or GameState.win\n      console.log(\"Game Over: All non-mine tiles revealed!\");\n    }\n    // MineCount === 0 is already handled in handleTileclick for gameover.\n\n    // If you need a \"tie\" condition for a game like Tic-Tac-Toe,\n    // you'd typically check if all non-mine tiles are revealed AND there are no remaining mines,\n    // and no one \"won\" by finding all mines first. Your current `checkWinner` logic is Tic-Tac-Toe specific.\n    // If it's a Minesweeper game, a \"tie\" might not be a primary end state.\n  }, [tiles, mines, gameState]); // Dependencies for checking win condition\n\n\n  return (\n    <div>\n      <h1>Minesweeper / Tic Tac Toe Hybrid</h1>\n      <h4>Current Turn: {turn} (Your client: {client.userID})</h4>\n      <h4>Mistakes - X: {mistakeCounts[\"X\"]}, O: {mistakeCounts[\"O\"]}</h4>\n      <h4>Mines Remaining: {mineCount}</h4>\n      <Board\n        player={player} // This 'player' is still hardcoded \"X\"\n        tiles={tiles}\n        onTileClick={handleTileclick}\n        strike={strike}\n      />\n      <GameOver gameState={gameState} />\n      <Reset gameState={gameState} onReset={handleReset} />\n    </div>\n  );\n}\n\nexport default TicTacToe;"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAClD,SAASC,sBAAsB,EAAEC,cAAc,QAAQ,mBAAmB;AAC1E,OAAOC,KAAK,MAAM,SAAS;AAC3B,OAAOC,QAAQ,MAAM,YAAY;AACjC,OAAOC,SAAS,MAAM,aAAa;AACnC,OAAOC,KAAK,MAAM,SAAS;AAC3B,OAAOC,KAAK,MAAM,SAAS,CAAC,CAAC;AAAA,SAAAC,MAAA,IAAAC,OAAA;AAE7B,SAASC,SAASA,CAAA,EAAG;EAAAC,EAAA;EACnB,MAAMC,MAAM,GAAG,GAAG,CAAC,CAAC;EACpB,MAAM,CAACC,IAAI,EAAEC,OAAO,CAAC,GAAGd,QAAQ,CAAC,GAAG,CAAC;EACrC,MAAM,CAACe,aAAa,EAAEC,gBAAgB,CAAC,GAAGhB,QAAQ,CAAC;IAAE,GAAG,EAAE,CAAC;IAAE,GAAG,EAAE;EAAE,CAAC,CAAC;EACtE,MAAM;IAAEiB;EAAQ,CAAC,GAAGhB,sBAAsB,CAAC,CAAC;EAC5C,MAAM;IAAEiB;EAAO,CAAC,GAAGhB,cAAc,CAAC,CAAC;EACnC,MAAM,CAACiB,KAAK,EAAEC,QAAQ,CAAC,GAAGpB,QAAQ,CAACqB,KAAK,CAAC,EAAE,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;EACxD,MAAM,CAACC,KAAK,EAAEC,QAAQ,CAAC,GAAGxB,QAAQ,CAACqB,KAAK,CAAC,EAAE,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;EACxD,MAAM,CAACG,SAAS,EAAEC,YAAY,CAAC,GAAG1B,QAAQ,CAAC,CAAC,CAAC;EAC7C,MAAM,CAAC2B,MAAM,EAAEC,SAAS,CAAC,GAAG5B,QAAQ,CAAC,IAAI,CAAC;EAC1C,MAAM,CAAC6B,SAAS,EAAEC,YAAY,CAAC,GAAG9B,QAAQ,CAACK,SAAS,CAAC0B,YAAY,CAAC;EAElEC,OAAO,CAACC,GAAG,CAAC,0BAA0B,CAAC;EACvCD,OAAO,CAACC,GAAG,CAAC,0BAA0B,EAAE;IAAEpB,IAAI;IAAEE,aAAa;IAAEU,SAAS;IAAEI,SAAS;IAAEV,KAAK,EAAEA,KAAK,CAACe,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;IAAEX,KAAK,EAAEA,KAAK,CAACW,KAAK,CAAC,CAAC,EAAE,CAAC;EAAE,CAAC,CAAC,CAAC,CAAC;;EAE5I;EACAnC,SAAS,CAAC,MAAM;IACdiC,OAAO,CAACC,GAAG,CAAC,uEAAuE,EAAEJ,SAAS,CAAC;IAC/F,IAAIA,SAAS,KAAKxB,SAAS,CAAC0B,YAAY,EAAE;MACxCC,OAAO,CAACC,GAAG,CAAC,yBAAyB,CAAC;MACtC,MAAME,OAAO,GAAG5B,KAAK,CAACkB,SAAS,CAAC;MAChCD,QAAQ,CAACW,OAAO,CAAC;MACjBL,YAAY,CAACzB,SAAS,CAAC+B,KAAK,CAAC;MAC7BJ,OAAO,CAACC,GAAG,CAAC,sDAAsD,CAAC;IACrE;EACF,CAAC,EAAE,CAACJ,SAAS,EAAEJ,SAAS,CAAC,CAAC,CAAC,CAAC;;EAE5B,MAAMY,eAAe,GAAG,MAAOC,KAAK,IAAK;IACvCN,OAAO,CAACC,GAAG,CAAC,yBAAyBK,KAAK,2BAA2B,CAAC;IACtEN,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAEJ,SAAS,CAAC;IAC5CG,OAAO,CAACC,GAAG,CAAC,uBAAuB,EAAEd,KAAK,CAACmB,KAAK,CAAC,CAAC;IAElD,IAAIT,SAAS,KAAKxB,SAAS,CAAC+B,KAAK,IAAIP,SAAS,KAAKxB,SAAS,CAACkC,UAAU,EAAE;MACvEP,OAAO,CAACC,GAAG,CAAC,4CAA4C,CAAC;MACzD;IACF;IACA,IAAId,KAAK,CAACmB,KAAK,CAAC,KAAK,IAAI,EAAE;MACzBN,OAAO,CAACC,GAAG,CAAC,uCAAuC,CAAC;MACpD;IACF;;IAEA;IACA,MAAMO,WAAW,GAAG3B,IAAI;IACxB,MAAM4B,oBAAoB,GAAG;MAAE,GAAG1B;IAAc,CAAC;IACjD,MAAM2B,gBAAgB,GAAGjB,SAAS;;IAElC;IACA,MAAMkB,QAAQ,GAAG,CAAC,GAAGxB,KAAK,CAAC;IAC3B,MAAMyB,MAAM,GAAGrB,KAAK,CAACe,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACpCK,QAAQ,CAACL,KAAK,CAAC,GAAGf,KAAK,CAACe,KAAK,CAAC,CAAC,CAAC;;IAEhC,IAAIO,gBAAgB,GAAGH,gBAAgB;IACvC,MAAMI,oBAAoB,GAAG;MAAE,GAAGL;IAAqB,CAAC;IACxD,IAAIM,gBAAgB,GAAGlB,SAAS,KAAKxB,SAAS,CAAC+B,KAAK,GAAG/B,SAAS,CAACkC,UAAU,GAAGV,SAAS,CAAC,CAAC;IACzF,IAAImB,QAAQ,GAAGR,WAAW,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG;IAE9C,IAAII,MAAM,EAAE;MACVZ,OAAO,CAACC,GAAG,CAAC,QAAQK,KAAK,aAAa,CAAC;MACvCO,gBAAgB,IAAI,CAAC;MACrBC,oBAAoB,CAACN,WAAW,CAAC,GAAG,CAACM,oBAAoB,CAACN,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;;MAElF,IAAIK,gBAAgB,KAAK,CAAC,EAAE;QAC1BE,gBAAgB,GAAG1C,SAAS,CAAC4C,QAAQ,CAAC,CAAC;QACvCjB,OAAO,CAACC,GAAG,CAAC,6BAA6B,CAAC;MAC5C;IACF;;IAEA;IACAD,OAAO,CAACC,GAAG,CAAC,yBAAyB,CAAC;IACtCb,QAAQ,CAACuB,QAAQ,CAAC;IAClBjB,YAAY,CAACmB,gBAAgB,CAAC;IAC9B7B,gBAAgB,CAAC8B,oBAAoB,CAAC;IACtChC,OAAO,CAACkC,QAAQ,CAAC;IACjBlB,YAAY,CAACiB,gBAAgB,CAAC;IAC9Bf,OAAO,CAACC,GAAG,CAAC,iEAAiE,EAAE;MAC7EU,QAAQ,EAAEA,QAAQ,CAACT,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;MAAE;MAChCW,gBAAgB;MAChBC,oBAAoB;MACpBE,QAAQ;MACRD;IACF,CAAC,CAAC;;IAGF;IACAf,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAC;IACzC,MAAMhB,OAAO,CAACiC,SAAS,CAAC;MACtBC,IAAI,EAAE,WAAW;MAAE;MACnBC,IAAI,EAAE;QACJjC,KAAK,EAAEwB,QAAQ;QAAE;QACjBpB,KAAK,EAAEA,KAAK;QAAE;QACdE,SAAS,EAAEoB,gBAAgB;QAAE;QAC7B9B,aAAa,EAAE+B,oBAAoB;QAAE;QACrCjC,IAAI,EAAEmC,QAAQ;QAAE;QAChBnB,SAAS,EAAEkB,gBAAgB,CAAE;MAC/B;IACF,CAAC,CAAC;IACFf,OAAO,CAACC,GAAG,CAAC,oCAAoC,CAAC;EACnD,CAAC;;EAED;EACAlC,SAAS,CAAC,MAAM;IACd,MAAMsD,eAAe,GAAIC,KAAK,IAAK;MACjCtB,OAAO,CAACC,GAAG,CAAC,0BAA0B,EAAEqB,KAAK,CAACH,IAAI,EAAE,YAAY,EAAEG,KAAK,CAACC,IAAI,CAACC,EAAE,CAAC;MAChFxB,OAAO,CAACC,GAAG,CAAC,wBAAwB,EAAEf,MAAM,CAACuC,MAAM,CAAC;;MAEpD;MACA,IAAIH,KAAK,CAACH,IAAI,KAAK,WAAW,IAAIG,KAAK,CAACC,IAAI,CAACC,EAAE,KAAKtC,MAAM,CAACuC,MAAM,EAAE;QACjEzB,OAAO,CAACC,GAAG,CAAC,6DAA6D,CAAC;QAC1ED,OAAO,CAACC,GAAG,CAAC,cAAc,EAAEqB,KAAK,CAACF,IAAI,CAAC;QACvChC,QAAQ,CAACkC,KAAK,CAACF,IAAI,CAACjC,KAAK,CAAC;QAC1BK,QAAQ,CAAC8B,KAAK,CAACF,IAAI,CAAC7B,KAAK,CAAC,CAAC,CAAC;QAC5BG,YAAY,CAAC4B,KAAK,CAACF,IAAI,CAAC3B,SAAS,CAAC;QAClCT,gBAAgB,CAACsC,KAAK,CAACF,IAAI,CAACrC,aAAa,CAAC;QAC1CD,OAAO,CAACwC,KAAK,CAACF,IAAI,CAACvC,IAAI,CAAC;QACxBiB,YAAY,CAACwB,KAAK,CAACF,IAAI,CAACvB,SAAS,CAAC;QAClCG,OAAO,CAACC,GAAG,CAAC,uBAAuB,CAAC;MACtC;MACA;MACA,IAAIqB,KAAK,CAACH,IAAI,KAAK,YAAY,IAAIG,KAAK,CAACC,IAAI,CAACC,EAAE,KAAKtC,MAAM,CAACuC,MAAM,EAAE;QAClEzB,OAAO,CAACC,GAAG,CAAC,8DAA8D,CAAC;QAC3ED,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAEqB,KAAK,CAACF,IAAI,CAAC;QAC7ChC,QAAQ,CAACkC,KAAK,CAACF,IAAI,CAACjC,KAAK,CAAC;QAC1BK,QAAQ,CAAC8B,KAAK,CAACF,IAAI,CAAC7B,KAAK,CAAC;QAC1BG,YAAY,CAAC4B,KAAK,CAACF,IAAI,CAAC3B,SAAS,CAAC;QAClCT,gBAAgB,CAACsC,KAAK,CAACF,IAAI,CAACrC,aAAa,CAAC;QAC1CD,OAAO,CAACwC,KAAK,CAACF,IAAI,CAACvC,IAAI,CAAC;QACxBiB,YAAY,CAACwB,KAAK,CAACF,IAAI,CAACvB,SAAS,CAAC;QAClCD,SAAS,CAAC0B,KAAK,CAACF,IAAI,CAACzB,MAAM,CAAC;QAC5BK,OAAO,CAACC,GAAG,CAAC,6BAA6B,CAAC;MAC5C;IACF,CAAC;;IAED;IACAD,OAAO,CAACC,GAAG,CAAC,mCAAmC,CAAC;IAChDhB,OAAO,CAACyC,EAAE,CAAC,OAAO,EAAEL,eAAe,CAAC;;IAEpC;IACA,OAAO,MAAM;MACXrB,OAAO,CAACC,GAAG,CAAC,mCAAmC,CAAC;MAChDhB,OAAO,CAAC0C,GAAG,CAAC,OAAO,EAAEN,eAAe,CAAC;IACvC,CAAC;EACH,CAAC,EAAE,CAACpC,OAAO,EAAEC,MAAM,CAACuC,MAAM,CAAC,CAAC,CAAC,CAAC;;EAE9B,MAAMG,WAAW,GAAG,MAAAA,CAAA,KAAY;IAC9B5B,OAAO,CAACC,GAAG,CAAC,wCAAwC,CAAC;IACrD,MAAM4B,YAAY,GAAGxC,KAAK,CAAC,EAAE,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;IACzC,MAAMwC,cAAc,GAAGvD,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IACjC,MAAMwD,oBAAoB,GAAG;MAAE,GAAG,EAAE,CAAC;MAAE,GAAG,EAAE;IAAE,CAAC;IAC/C,MAAMC,gBAAgB,GAAG,CAAC;;IAE1B;IACAhC,OAAO,CAACC,GAAG,CAAC,iCAAiC,CAAC;IAC9Cb,QAAQ,CAACyC,YAAY,CAAC;IACtBrC,QAAQ,CAACsC,cAAc,CAAC;IACxBhD,OAAO,CAAC,GAAG,CAAC;IACZE,gBAAgB,CAAC+C,oBAAoB,CAAC;IACtCrC,YAAY,CAACsC,gBAAgB,CAAC;IAC9BlC,YAAY,CAACzB,SAAS,CAAC0B,YAAY,CAAC,CAAC,CAAC;IACtCH,SAAS,CAAC,IAAI,CAAC;IACfI,OAAO,CAACC,GAAG,CAAC,oBAAoB,CAAC;;IAEjC;IACAD,OAAO,CAACC,GAAG,CAAC,6BAA6B,CAAC;IAC1C,MAAMhB,OAAO,CAACiC,SAAS,CAAC;MACtBC,IAAI,EAAE,YAAY;MAClBC,IAAI,EAAE;QACJjC,KAAK,EAAE0C,YAAY;QACnBtC,KAAK,EAAEuC,cAAc;QACrBjD,IAAI,EAAE,GAAG;QACTY,SAAS,EAAEuC,gBAAgB;QAC3BjD,aAAa,EAAEgD,oBAAoB;QACnClC,SAAS,EAAExB,SAAS,CAAC0B,YAAY;QACjCJ,MAAM,EAAE;MACV;IACF,CAAC,CAAC;IACFK,OAAO,CAACC,GAAG,CAAC,qCAAqC,CAAC;EACpD,CAAC;;EAED;EACAlC,SAAS,CAAC,MAAM;IACdiC,OAAO,CAACC,GAAG,CAAC,mEAAmE,CAAC;IAChF,MAAMgC,eAAe,GAAG1C,KAAK,CAAC2C,MAAM,CAACC,CAAC,IAAIA,CAAC,KAAK,CAAC,CAAC,CAAC,CAACC,MAAM;IAC1D,MAAMC,oBAAoB,GAAGlD,KAAK,CAAC+C,MAAM,CAAC,CAACI,CAAC,EAAEC,CAAC,KAAKD,CAAC,KAAK,IAAI,IAAI/C,KAAK,CAACgD,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAACH,MAAM;IAEzF,IAAIvC,SAAS,KAAKxB,SAAS,CAACkC,UAAU,IAAI8B,oBAAoB,KAAKJ,eAAe,EAAE;MAClFnC,YAAY,CAACzB,SAAS,CAAC4C,QAAQ,CAAC,CAAC,CAAC;MAClCjB,OAAO,CAACC,GAAG,CAAC,yCAAyC,CAAC;IACxD;IACA;;IAEA;IACA;IACA;IACA;EACF,CAAC,EAAE,CAACd,KAAK,EAAEI,KAAK,EAAEM,SAAS,CAAC,CAAC,CAAC,CAAC;;EAG/B,oBACEpB,OAAA;IAAA+D,QAAA,gBACE/D,OAAA;MAAA+D,QAAA,EAAI;IAAgC;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAI,CAAC,eACzCnE,OAAA;MAAA+D,QAAA,GAAI,gBAAc,EAAC3D,IAAI,EAAC,iBAAe,EAACK,MAAM,CAACuC,MAAM,EAAC,GAAC;IAAA;MAAAgB,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAI,CAAC,eAC5DnE,OAAA;MAAA+D,QAAA,GAAI,gBAAc,EAACzD,aAAa,CAAC,GAAG,CAAC,EAAC,OAAK,EAACA,aAAa,CAAC,GAAG,CAAC;IAAA;MAAA0D,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAK,CAAC,eACpEnE,OAAA;MAAA+D,QAAA,GAAI,mBAAiB,EAAC/C,SAAS;IAAA;MAAAgD,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAK,CAAC,eACrCnE,OAAA,CAACN,KAAK;MACJS,MAAM,EAAEA,MAAO,CAAC;MAAA;MAChBO,KAAK,EAAEA,KAAM;MACb0D,WAAW,EAAExC,eAAgB;MAC7BV,MAAM,EAAEA;IAAO;MAAA8C,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAChB,CAAC,eACFnE,OAAA,CAACL,QAAQ;MAACyB,SAAS,EAAEA;IAAU;MAAA4C,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAE,CAAC,eAClCnE,OAAA,CAACH,KAAK;MAACuB,SAAS,EAAEA,SAAU;MAACiD,OAAO,EAAElB;IAAY;MAAAa,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAE,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAClD,CAAC;AAEV;AAACjE,EAAA,CArNQD,SAAS;EAAA,QAIIT,sBAAsB,EACvBC,cAAc;AAAA;AAAA6E,EAAA,GAL1BrE,SAAS;AAuNlB,eAAeA,SAAS;AAAC,IAAAqE,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}