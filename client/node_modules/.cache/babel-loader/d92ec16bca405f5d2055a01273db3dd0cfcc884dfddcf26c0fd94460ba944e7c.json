{"ast":null,"code":"import { nanoid } from 'nanoid';\nimport { CUSTOM_MESSAGE_TYPE } from '../../constants/messageTypes';\nimport { isMessageEdited } from '../Message/utils';\nimport { isDate } from '../../i18n';\n/**\n * processMessages - Transform the input message list according to config parameters\n *\n * Inserts date separators btw. messages created on different dates or before unread incoming messages. By default:\n * - enabled in main message list\n * - disabled in virtualized message list\n * - disabled in thread\n *\n * Allows to filter out deleted messages, contolled by hideDeletedMessages param. This is disabled by default.\n *\n * Sets Giphy preview message for VirtualizedMessageList\n *\n * The only required params are messages and userId, the rest are config params:\n *\n * @return {LocalMessage[]} Transformed list of messages\n */\nexport const processMessages = params => {\n  const {\n    messages,\n    reviewProcessedMessage,\n    setGiphyPreviewMessage,\n    ...context\n  } = params;\n  const {\n    enableDateSeparator,\n    hideDeletedMessages,\n    hideNewMessageSeparator,\n    lastRead,\n    userId\n  } = context;\n  let unread = false;\n  let ephemeralMessagePresent = false;\n  let lastDateSeparator;\n  const newMessages = [];\n  for (let i = 0; i < messages.length; i += 1) {\n    const message = messages[i];\n    if (hideDeletedMessages && message.type === 'deleted') {\n      continue;\n    }\n    if (setGiphyPreviewMessage && message.type === 'ephemeral' && message.command === 'giphy') {\n      ephemeralMessagePresent = true;\n      setGiphyPreviewMessage(message);\n      continue;\n    }\n    const changes = [];\n    const messageDate = message.created_at && isDate(message.created_at) && message.created_at.toDateString() || '';\n    const previousMessage = messages[i - 1];\n    let prevMessageDate = messageDate;\n    if (enableDateSeparator && previousMessage?.created_at && isDate(previousMessage.created_at)) {\n      prevMessageDate = previousMessage.created_at.toDateString();\n    }\n    if (!unread && !hideNewMessageSeparator) {\n      unread = lastRead && message.created_at && new Date(lastRead) < message.created_at || false;\n      // do not show date separator for current user's messages\n      if (enableDateSeparator && unread && message.user?.id !== userId) {\n        changes.push({\n          customType: CUSTOM_MESSAGE_TYPE.date,\n          date: message.created_at,\n          id: makeDateMessageId(message.created_at),\n          unread\n        });\n      }\n    }\n    if (enableDateSeparator && (i === 0 ||\n    // always put date separator before the first message\n    messageDate !== prevMessageDate ||\n    // add date separator btw. 2 messages created on different date\n    // if hiding deleted messages replace the previous deleted message(s) with A separator if the last rendered message was created on different date\n    hideDeletedMessages && previousMessage?.type === 'deleted' && lastDateSeparator !== messageDate) && !isDateSeparatorMessage(changes[changes.length - 1]) // do not show two date separators in a row)\n    ) {\n      lastDateSeparator = messageDate;\n      changes.push({\n        customType: CUSTOM_MESSAGE_TYPE.date,\n        date: message.created_at,\n        id: makeDateMessageId(message.created_at)\n      }, message);\n    } else {\n      changes.push(message);\n    }\n    newMessages.push(...(reviewProcessedMessage?.({\n      changes,\n      context,\n      index: i,\n      messages,\n      processedMessages: newMessages\n    }) || changes));\n  }\n  // clean up the giphy preview component state after a Cancel action\n  if (setGiphyPreviewMessage && !ephemeralMessagePresent) {\n    setGiphyPreviewMessage(undefined);\n  }\n  return newMessages;\n};\nexport const makeIntroMessage = () => ({\n  customType: CUSTOM_MESSAGE_TYPE.intro,\n  id: nanoid()\n});\nexport const makeDateMessageId = date => {\n  let idSuffix;\n  try {\n    idSuffix = !date ? nanoid() : date instanceof Date ? date.toISOString() : date;\n  } catch (e) {\n    idSuffix = nanoid();\n  }\n  return `${CUSTOM_MESSAGE_TYPE.date}-${idSuffix}`;\n};\n// fast since it usually iterates just the last few messages\nexport const getLastReceived = messages => {\n  for (let i = messages.length - 1; i > 0; i -= 1) {\n    if (messages[i].status === 'received') {\n      return messages[i].id;\n    }\n  }\n  return null;\n};\nexport const getReadStates = (messages, read = {}, returnAllReadData) => {\n  // create object with empty array for each message id\n  const readData = {};\n  Object.values(read).forEach(readState => {\n    if (!readState.last_read) return;\n    let userLastReadMsgId;\n    // loop messages sent by current user and add read data for other users in channel\n    messages.forEach(msg => {\n      if (msg.created_at && msg.created_at < readState.last_read) {\n        userLastReadMsgId = msg.id;\n        // if true, save other user's read data for all messages they've read\n        if (returnAllReadData) {\n          if (!readData[userLastReadMsgId]) {\n            readData[userLastReadMsgId] = [];\n          }\n          readData[userLastReadMsgId].push(readState.user);\n        }\n      }\n    });\n    // if true, only save read data for other user's last read message\n    if (userLastReadMsgId && !returnAllReadData) {\n      if (!readData[userLastReadMsgId]) {\n        readData[userLastReadMsgId] = [];\n      }\n      readData[userLastReadMsgId].push(readState.user);\n    }\n  });\n  return readData;\n};\nexport const insertIntro = (messages, headerPosition) => {\n  const newMessages = messages;\n  const intro = makeIntroMessage();\n  // if no headerPosition is set, HeaderComponent will go at the top\n  if (!headerPosition) {\n    newMessages.unshift(intro);\n    return newMessages;\n  }\n  // if no messages, intro gets inserted\n  if (!newMessages.length) {\n    newMessages.unshift(intro);\n    return newMessages;\n  }\n  // else loop over the messages\n  for (let i = 0; i < messages.length; i += 1) {\n    const messageTime = isDate(messages[i].created_at) ? messages[i].created_at.getTime() : null;\n    const nextMessageTime = isDate(messages[i + 1].created_at) ? messages[i + 1].created_at.getTime() : null;\n    // header position is smaller than message time so comes after;\n    if (messageTime && messageTime < headerPosition) {\n      // if header position is also smaller than message time continue;\n      if (nextMessageTime && nextMessageTime < headerPosition) {\n        if (messages[i + 1] && isDateSeparatorMessage(messages[i + 1])) continue;\n        if (!nextMessageTime) {\n          newMessages.push(intro);\n          return newMessages;\n        }\n      } else {\n        newMessages.splice(i + 1, 0, intro);\n        return newMessages;\n      }\n    }\n  }\n  return newMessages;\n};\nexport const getGroupStyles = (message, previousMessage, nextMessage, noGroupByUser, maxTimeBetweenGroupedMessages) => {\n  if (isDateSeparatorMessage(message) || isIntroMessage(message)) return '';\n  if (noGroupByUser || message.attachments?.length !== 0) return 'single';\n  const isTopMessage = !previousMessage || isIntroMessage(previousMessage) || isDateSeparatorMessage(previousMessage) || previousMessage.type === 'system' || previousMessage.type === 'error' || previousMessage.attachments?.length !== 0 || message.user?.id !== previousMessage.user?.id || previousMessage.deleted_at || message.reaction_groups && Object.keys(message.reaction_groups).length > 0 || isMessageEdited(previousMessage) || maxTimeBetweenGroupedMessages !== undefined && previousMessage.created_at && message.created_at && new Date(message.created_at).getTime() - new Date(previousMessage.created_at).getTime() > maxTimeBetweenGroupedMessages;\n  const isBottomMessage = !nextMessage || isIntroMessage(nextMessage) || isDateSeparatorMessage(nextMessage) || nextMessage.type === 'system' || nextMessage.type === 'error' || nextMessage.attachments?.length !== 0 || message.user?.id !== nextMessage.user?.id || nextMessage.deleted_at || nextMessage.reaction_groups && Object.keys(nextMessage.reaction_groups).length > 0 || isMessageEdited(message) || maxTimeBetweenGroupedMessages !== undefined && nextMessage.created_at && message.created_at && new Date(nextMessage.created_at).getTime() - new Date(message.created_at).getTime() > maxTimeBetweenGroupedMessages;\n  if (!isTopMessage && !isBottomMessage) {\n    if (message.deleted_at || message.type === 'error') return 'single';\n    return 'middle';\n  }\n  if (isBottomMessage) {\n    if (isTopMessage || message.deleted_at || message.type === 'error') return 'single';\n    return 'bottom';\n  }\n  if (isTopMessage) return 'top';\n  return '';\n};\n// \"Probably\" included, because it may happen that the last page was returned and it has exactly the size of the limit\n// but the back-end cannot provide us with information on whether it has still more messages in the DB\n// FIXME: once the pagination state is moved from Channel to MessageList, these should be moved as well.\n//  The MessageList should have configurable the limit for performing the requests.\n//  This parameter would then be used within these functions\nexport const hasMoreMessagesProbably = (returnedCountMessages, limit) => returnedCountMessages >= limit;\n// @deprecated\nexport const hasNotMoreMessages = (returnedCountMessages, limit) => returnedCountMessages < limit;\nexport function isIntroMessage(message) {\n  return message.customType === CUSTOM_MESSAGE_TYPE.intro;\n}\nexport function isDateSeparatorMessage(message) {\n  return message !== null && typeof message === 'object' && message.customType === CUSTOM_MESSAGE_TYPE.date && isDate(message.date);\n}\nexport function isLocalMessage(message) {\n  return !isDateSeparatorMessage(message) && !isIntroMessage(message);\n}\nexport const getIsFirstUnreadMessage = ({\n  firstUnreadMessageId,\n  isFirstMessage,\n  lastReadDate,\n  lastReadMessageId,\n  message,\n  previousMessage,\n  unreadMessageCount = 0\n}) => {\n  // prevent showing unread indicator in threads\n  if (message.parent_id) return false;\n  const createdAtTimestamp = message.created_at && new Date(message.created_at).getTime();\n  const lastReadTimestamp = lastReadDate?.getTime();\n  const messageIsUnread = !!createdAtTimestamp && !!lastReadTimestamp && createdAtTimestamp > lastReadTimestamp;\n  const previousMessageIsLastRead = !!lastReadMessageId && lastReadMessageId === previousMessage?.id;\n  return firstUnreadMessageId === message.id || !!unreadMessageCount && messageIsUnread && (isFirstMessage || previousMessageIsLastRead);\n};","map":{"version":3,"names":["nanoid","CUSTOM_MESSAGE_TYPE","isMessageEdited","isDate","processMessages","params","messages","reviewProcessedMessage","setGiphyPreviewMessage","context","enableDateSeparator","hideDeletedMessages","hideNewMessageSeparator","lastRead","userId","unread","ephemeralMessagePresent","lastDateSeparator","newMessages","i","length","message","type","command","changes","messageDate","created_at","toDateString","previousMessage","prevMessageDate","Date","user","id","push","customType","date","makeDateMessageId","isDateSeparatorMessage","index","processedMessages","undefined","makeIntroMessage","intro","idSuffix","toISOString","e","getLastReceived","status","getReadStates","read","returnAllReadData","readData","Object","values","forEach","readState","last_read","userLastReadMsgId","msg","insertIntro","headerPosition","unshift","messageTime","getTime","nextMessageTime","splice","getGroupStyles","nextMessage","noGroupByUser","maxTimeBetweenGroupedMessages","isIntroMessage","attachments","isTopMessage","deleted_at","reaction_groups","keys","isBottomMessage","hasMoreMessagesProbably","returnedCountMessages","limit","hasNotMoreMessages","isLocalMessage","getIsFirstUnreadMessage","firstUnreadMessageId","isFirstMessage","lastReadDate","lastReadMessageId","unreadMessageCount","parent_id","createdAtTimestamp","lastReadTimestamp","messageIsUnread","previousMessageIsLastRead"],"sources":["/Users/yashwantmoharil/Desktop/football-battlegrounds/client/node_modules/stream-chat-react/dist/components/MessageList/utils.js"],"sourcesContent":["import { nanoid } from 'nanoid';\nimport { CUSTOM_MESSAGE_TYPE } from '../../constants/messageTypes';\nimport { isMessageEdited } from '../Message/utils';\nimport { isDate } from '../../i18n';\n/**\n * processMessages - Transform the input message list according to config parameters\n *\n * Inserts date separators btw. messages created on different dates or before unread incoming messages. By default:\n * - enabled in main message list\n * - disabled in virtualized message list\n * - disabled in thread\n *\n * Allows to filter out deleted messages, contolled by hideDeletedMessages param. This is disabled by default.\n *\n * Sets Giphy preview message for VirtualizedMessageList\n *\n * The only required params are messages and userId, the rest are config params:\n *\n * @return {LocalMessage[]} Transformed list of messages\n */\nexport const processMessages = (params) => {\n    const { messages, reviewProcessedMessage, setGiphyPreviewMessage, ...context } = params;\n    const { enableDateSeparator, hideDeletedMessages, hideNewMessageSeparator, lastRead, userId, } = context;\n    let unread = false;\n    let ephemeralMessagePresent = false;\n    let lastDateSeparator;\n    const newMessages = [];\n    for (let i = 0; i < messages.length; i += 1) {\n        const message = messages[i];\n        if (hideDeletedMessages && message.type === 'deleted') {\n            continue;\n        }\n        if (setGiphyPreviewMessage &&\n            message.type === 'ephemeral' &&\n            message.command === 'giphy') {\n            ephemeralMessagePresent = true;\n            setGiphyPreviewMessage(message);\n            continue;\n        }\n        const changes = [];\n        const messageDate = (message.created_at &&\n            isDate(message.created_at) &&\n            message.created_at.toDateString()) ||\n            '';\n        const previousMessage = messages[i - 1];\n        let prevMessageDate = messageDate;\n        if (enableDateSeparator &&\n            previousMessage?.created_at &&\n            isDate(previousMessage.created_at)) {\n            prevMessageDate = previousMessage.created_at.toDateString();\n        }\n        if (!unread && !hideNewMessageSeparator) {\n            unread =\n                (lastRead && message.created_at && new Date(lastRead) < message.created_at) ||\n                    false;\n            // do not show date separator for current user's messages\n            if (enableDateSeparator && unread && message.user?.id !== userId) {\n                changes.push({\n                    customType: CUSTOM_MESSAGE_TYPE.date,\n                    date: message.created_at,\n                    id: makeDateMessageId(message.created_at),\n                    unread,\n                });\n            }\n        }\n        if (enableDateSeparator &&\n            (i === 0 || // always put date separator before the first message\n                messageDate !== prevMessageDate || // add date separator btw. 2 messages created on different date\n                // if hiding deleted messages replace the previous deleted message(s) with A separator if the last rendered message was created on different date\n                (hideDeletedMessages &&\n                    previousMessage?.type === 'deleted' &&\n                    lastDateSeparator !== messageDate)) &&\n            !isDateSeparatorMessage(changes[changes.length - 1]) // do not show two date separators in a row)\n        ) {\n            lastDateSeparator = messageDate;\n            changes.push({\n                customType: CUSTOM_MESSAGE_TYPE.date,\n                date: message.created_at,\n                id: makeDateMessageId(message.created_at),\n            }, message);\n        }\n        else {\n            changes.push(message);\n        }\n        newMessages.push(...(reviewProcessedMessage?.({\n            changes,\n            context,\n            index: i,\n            messages,\n            processedMessages: newMessages,\n        }) || changes));\n    }\n    // clean up the giphy preview component state after a Cancel action\n    if (setGiphyPreviewMessage && !ephemeralMessagePresent) {\n        setGiphyPreviewMessage(undefined);\n    }\n    return newMessages;\n};\nexport const makeIntroMessage = () => ({\n    customType: CUSTOM_MESSAGE_TYPE.intro,\n    id: nanoid(),\n});\nexport const makeDateMessageId = (date) => {\n    let idSuffix;\n    try {\n        idSuffix = !date ? nanoid() : date instanceof Date ? date.toISOString() : date;\n    }\n    catch (e) {\n        idSuffix = nanoid();\n    }\n    return `${CUSTOM_MESSAGE_TYPE.date}-${idSuffix}`;\n};\n// fast since it usually iterates just the last few messages\nexport const getLastReceived = (messages) => {\n    for (let i = messages.length - 1; i > 0; i -= 1) {\n        if (messages[i].status === 'received') {\n            return messages[i].id;\n        }\n    }\n    return null;\n};\nexport const getReadStates = (messages, read = {}, returnAllReadData) => {\n    // create object with empty array for each message id\n    const readData = {};\n    Object.values(read).forEach((readState) => {\n        if (!readState.last_read)\n            return;\n        let userLastReadMsgId;\n        // loop messages sent by current user and add read data for other users in channel\n        messages.forEach((msg) => {\n            if (msg.created_at && msg.created_at < readState.last_read) {\n                userLastReadMsgId = msg.id;\n                // if true, save other user's read data for all messages they've read\n                if (returnAllReadData) {\n                    if (!readData[userLastReadMsgId]) {\n                        readData[userLastReadMsgId] = [];\n                    }\n                    readData[userLastReadMsgId].push(readState.user);\n                }\n            }\n        });\n        // if true, only save read data for other user's last read message\n        if (userLastReadMsgId && !returnAllReadData) {\n            if (!readData[userLastReadMsgId]) {\n                readData[userLastReadMsgId] = [];\n            }\n            readData[userLastReadMsgId].push(readState.user);\n        }\n    });\n    return readData;\n};\nexport const insertIntro = (messages, headerPosition) => {\n    const newMessages = messages;\n    const intro = makeIntroMessage();\n    // if no headerPosition is set, HeaderComponent will go at the top\n    if (!headerPosition) {\n        newMessages.unshift(intro);\n        return newMessages;\n    }\n    // if no messages, intro gets inserted\n    if (!newMessages.length) {\n        newMessages.unshift(intro);\n        return newMessages;\n    }\n    // else loop over the messages\n    for (let i = 0; i < messages.length; i += 1) {\n        const messageTime = isDate(messages[i].created_at)\n            ? messages[i].created_at.getTime()\n            : null;\n        const nextMessageTime = isDate(messages[i + 1].created_at)\n            ? messages[i + 1].created_at.getTime()\n            : null;\n        // header position is smaller than message time so comes after;\n        if (messageTime && messageTime < headerPosition) {\n            // if header position is also smaller than message time continue;\n            if (nextMessageTime && nextMessageTime < headerPosition) {\n                if (messages[i + 1] && isDateSeparatorMessage(messages[i + 1]))\n                    continue;\n                if (!nextMessageTime) {\n                    newMessages.push(intro);\n                    return newMessages;\n                }\n            }\n            else {\n                newMessages.splice(i + 1, 0, intro);\n                return newMessages;\n            }\n        }\n    }\n    return newMessages;\n};\nexport const getGroupStyles = (message, previousMessage, nextMessage, noGroupByUser, maxTimeBetweenGroupedMessages) => {\n    if (isDateSeparatorMessage(message) || isIntroMessage(message))\n        return '';\n    if (noGroupByUser || message.attachments?.length !== 0)\n        return 'single';\n    const isTopMessage = !previousMessage ||\n        isIntroMessage(previousMessage) ||\n        isDateSeparatorMessage(previousMessage) ||\n        previousMessage.type === 'system' ||\n        previousMessage.type === 'error' ||\n        previousMessage.attachments?.length !== 0 ||\n        message.user?.id !== previousMessage.user?.id ||\n        previousMessage.deleted_at ||\n        (message.reaction_groups && Object.keys(message.reaction_groups).length > 0) ||\n        isMessageEdited(previousMessage) ||\n        (maxTimeBetweenGroupedMessages !== undefined &&\n            previousMessage.created_at &&\n            message.created_at &&\n            new Date(message.created_at).getTime() -\n                new Date(previousMessage.created_at).getTime() >\n                maxTimeBetweenGroupedMessages);\n    const isBottomMessage = !nextMessage ||\n        isIntroMessage(nextMessage) ||\n        isDateSeparatorMessage(nextMessage) ||\n        nextMessage.type === 'system' ||\n        nextMessage.type === 'error' ||\n        nextMessage.attachments?.length !== 0 ||\n        message.user?.id !== nextMessage.user?.id ||\n        nextMessage.deleted_at ||\n        (nextMessage.reaction_groups &&\n            Object.keys(nextMessage.reaction_groups).length > 0) ||\n        isMessageEdited(message) ||\n        (maxTimeBetweenGroupedMessages !== undefined &&\n            nextMessage.created_at &&\n            message.created_at &&\n            new Date(nextMessage.created_at).getTime() -\n                new Date(message.created_at).getTime() >\n                maxTimeBetweenGroupedMessages);\n    if (!isTopMessage && !isBottomMessage) {\n        if (message.deleted_at || message.type === 'error')\n            return 'single';\n        return 'middle';\n    }\n    if (isBottomMessage) {\n        if (isTopMessage || message.deleted_at || message.type === 'error')\n            return 'single';\n        return 'bottom';\n    }\n    if (isTopMessage)\n        return 'top';\n    return '';\n};\n// \"Probably\" included, because it may happen that the last page was returned and it has exactly the size of the limit\n// but the back-end cannot provide us with information on whether it has still more messages in the DB\n// FIXME: once the pagination state is moved from Channel to MessageList, these should be moved as well.\n//  The MessageList should have configurable the limit for performing the requests.\n//  This parameter would then be used within these functions\nexport const hasMoreMessagesProbably = (returnedCountMessages, limit) => returnedCountMessages >= limit;\n// @deprecated\nexport const hasNotMoreMessages = (returnedCountMessages, limit) => returnedCountMessages < limit;\nexport function isIntroMessage(message) {\n    return message.customType === CUSTOM_MESSAGE_TYPE.intro;\n}\nexport function isDateSeparatorMessage(message) {\n    return (message !== null &&\n        typeof message === 'object' &&\n        message.customType === CUSTOM_MESSAGE_TYPE.date &&\n        isDate(message.date));\n}\nexport function isLocalMessage(message) {\n    return !isDateSeparatorMessage(message) && !isIntroMessage(message);\n}\nexport const getIsFirstUnreadMessage = ({ firstUnreadMessageId, isFirstMessage, lastReadDate, lastReadMessageId, message, previousMessage, unreadMessageCount = 0, }) => {\n    // prevent showing unread indicator in threads\n    if (message.parent_id)\n        return false;\n    const createdAtTimestamp = message.created_at && new Date(message.created_at).getTime();\n    const lastReadTimestamp = lastReadDate?.getTime();\n    const messageIsUnread = !!createdAtTimestamp && !!lastReadTimestamp && createdAtTimestamp > lastReadTimestamp;\n    const previousMessageIsLastRead = !!lastReadMessageId && lastReadMessageId === previousMessage?.id;\n    return (firstUnreadMessageId === message.id ||\n        (!!unreadMessageCount &&\n            messageIsUnread &&\n            (isFirstMessage || previousMessageIsLastRead)));\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}