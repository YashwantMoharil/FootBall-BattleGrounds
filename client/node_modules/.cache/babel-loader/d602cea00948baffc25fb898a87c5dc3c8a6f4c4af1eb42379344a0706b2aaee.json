{"ast":null,"code":"var _jsxFileName = \"/Users/yashwantmoharil/Desktop/football-battlegrounds/client/src/Components/JoinTicTacToe.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState } from \"react\"; // Added useState\nimport { useChannelStateContext, useChatContext } from \"stream-chat-react\";\nimport Board from \"./Board\";\nimport GameOver from \"./GameOver\";\nimport GameState from \"./GameState\";\nimport Reset from \"./Reset\";\nimport Mines from \"./Mines\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction TicTacToe() {\n  _s();\n  const player = \"X\"; // This seems to be a fixed player for the local client. In a real multi-player game, you'd determine this dynamically.\n  const [turn, setTurn] = useState(\"X\");\n  const [mistakeCounts, setMistakeCounts] = useState({\n    \"X\": 0,\n    \"O\": 0\n  });\n  const {\n    channel\n  } = useChannelStateContext();\n  const {\n    client\n  } = useChatContext();\n  const [tiles, setTiles] = useState(Array(64).fill(null));\n  const [mines, setMines] = useState(Array(64).fill(null));\n  const [mineCount, setMineCount] = useState(5);\n  const [strike, setStrike] = useState(null);\n  const [gameState, setGameState] = useState(GameState.mineCreation);\n\n  // Initial mine creation - runs once when component mounts\n  useEffect(() => {\n    if (gameState === GameState.mineCreation) {\n      let newGrid = Mines(mineCount);\n      setMines(newGrid);\n      setGameState(GameState.start);\n    }\n  }, [gameState, mineCount]); // Dependency on gameState to ensure it runs when mineCreation state is active\n\n  const handleTileclick = async index => {\n    if (gameState !== GameState.start && gameState !== GameState.inProgress) return;\n    if (tiles[index] !== null) return; // Prevent clicking on an already revealed tile\n\n    const newTiles = [...tiles];\n    newTiles[index] = mines[index]; // Reveal the tile\n\n    let newMineCount = mineCount;\n    const newMistakeCounts = {\n      ...mistakeCounts\n    };\n    let newTurn = turn === 'X' ? 'O' : 'X';\n    let newGameState = GameState.inProgress;\n    if (newTiles[index] === -1) {\n      // If it's a mine\n      newMineCount = mineCount - 1;\n      newMistakeCounts[turn] = newMistakeCounts[turn] + 1; // Increment mistake for the current player\n      if (newMineCount === 0) {\n        newGameState = GameState.gameover; // All mines found\n      }\n    }\n\n    // Update local state immediately\n    setTiles(newTiles);\n    setMineCount(newMineCount);\n    setMistakeCounts(newMistakeCounts);\n    setTurn(newTurn);\n    setGameState(newGameState);\n\n    // Send the updated state to other clients\n    await channel.sendEvent({\n      type: \"game-move\",\n      data: {\n        tiles: newTiles,\n        mines: mines,\n        // Mines array doesn't change after initial creation, so current `mines` is fine\n        turn: newTurn,\n        mineCount: newMineCount,\n        mistakeCounts: newMistakeCounts,\n        gameState: newGameState\n      }\n    });\n  };\n\n  // Effect to listen for game-move events from other players\n  useEffect(() => {\n    const handler = event => {\n      // Only process events from other users\n      if (event.type === \"game-move\" && event.user.id !== client.userID) {\n        // Apply the synced state from the event data\n        setTiles(event.data.tiles);\n        setMines(event.data.mines);\n        setTurn(event.data.turn);\n        setMineCount(event.data.mineCount);\n        setMistakeCounts(event.data.mistakeCounts);\n        setGameState(event.data.gameState);\n      }\n    };\n    channel.on(\"event\", handler);\n\n    // Cleanup: remove the event listener when the component unmounts\n    return () => channel.off(\"event\", handler);\n  }, [channel, client.userID]); // Dependencies: channel and client.userID\n\n  const handleReset = async () => {\n    // Make handleReset async to send event\n    const initialTiles = Array(64).fill(null);\n    const initialMines = Mines(5); // Regenerate mines for a new game\n    const initialMistakeCounts = {\n      \"X\": 0,\n      \"O\": 0\n    };\n    const initialMineCount = 5;\n    setTiles(initialTiles);\n    setMines(initialMines); // Set new mines\n    setTurn(\"X\");\n    setMistakeCounts(initialMistakeCounts);\n    setMineCount(initialMineCount);\n    setGameState(GameState.start); // Back to start after reset\n    setStrike(null); // Clear any strike indicator\n\n    // Send reset event to other clients\n    await channel.sendEvent({\n      type: \"game-reset\",\n      data: {\n        tiles: initialTiles,\n        mines: initialMines,\n        turn: \"X\",\n        mineCount: initialMineCount,\n        mistakeCounts: initialMistakeCounts,\n        gameState: GameState.start,\n        strike: null\n      }\n    });\n  };\n\n  // Add an effect to listen for game-reset events\n  useEffect(() => {\n    const resetHandler = event => {\n      if (event.type === \"game-reset\" && event.user.id !== client.userID) {\n        setTiles(event.data.tiles);\n        setMines(event.data.mines);\n        setTurn(event.data.turn);\n        setMineCount(event.data.mineCount);\n        setMistakeCounts(event.data.mistakeCounts);\n        setGameState(event.data.gameState);\n        setStrike(event.data.strike);\n      }\n    };\n    channel.on(\"event\", resetHandler);\n    return () => channel.off(\"event\", resetHandler);\n  }, [channel, client.userID]);\n\n  // `checkWinner` logic for Tic-Tac-Toe doesn't directly apply to Minesweeper.\n  // In Minesweeper, the game ends when all non-mine tiles are revealed or all mines are found.\n  // Your `checkWinner` currently only checks for a full board.\n  // You might want to rename this or adjust its logic to fit Minesweeper's win/loss conditions.\n  useEffect(() => {\n    // This part should be re-evaluated for Minesweeper's win/loss conditions.\n    // A Tic-Tac-Toe \"tie\" doesn't quite fit here.\n    // If you want to check if all non-mine tiles are revealed for a win, you'd iterate through tiles\n    // and check if all non-mine tiles (mines[i] !== -1) have been revealed (tiles[i] !== null).\n    const revealedNonMineTiles = tiles.filter((tile, i) => tile !== null && mines[i] !== -1).length;\n    const totalNonMineTiles = mines.filter(mine => mine !== -1).length;\n    if (gameState === GameState.inProgress && revealedNonMineTiles === totalNonMineTiles) {\n      setGameState(GameState.gameover); // Or GameState.win if you have one\n      // You might want to determine a winner here based on mistake counts or just declare a team win\n    }\n  }, [tiles, mines, gameState]); // Dependencies for checking win condition\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Minesweeper Tic-Tac-Toe (Hybrid)\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 165,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"h4\", {\n      children: [\"Current Turn: \", turn]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 166,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"h4\", {\n      children: [\"Mistakes: X: \", mistakeCounts[\"X\"], \", O: \", mistakeCounts[\"O\"]]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 167,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"h4\", {\n      children: [\"Mines Remaining: \", mineCount]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 168,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Board, {\n      player: player,\n      tiles: tiles,\n      onTileClick: handleTileclick,\n      strike: strike\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 169,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(GameOver, {\n      gameState: gameState\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 175,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Reset, {\n      gameState: gameState,\n      onReset: handleReset\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 176,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 164,\n    columnNumber: 5\n  }, this);\n}\n_s(TicTacToe, \"KqiqJzWxq9G0iLitGA7H3qLihJA=\", false, function () {\n  return [useChannelStateContext, useChatContext];\n});\n_c = TicTacToe;\nexport default TicTacToe;\nvar _c;\n$RefreshReg$(_c, \"TicTacToe\");","map":{"version":3,"names":["React","useEffect","useState","useChannelStateContext","useChatContext","Board","GameOver","GameState","Reset","Mines","jsxDEV","_jsxDEV","TicTacToe","_s","player","turn","setTurn","mistakeCounts","setMistakeCounts","channel","client","tiles","setTiles","Array","fill","mines","setMines","mineCount","setMineCount","strike","setStrike","gameState","setGameState","mineCreation","newGrid","start","handleTileclick","index","inProgress","newTiles","newMineCount","newMistakeCounts","newTurn","newGameState","gameover","sendEvent","type","data","handler","event","user","id","userID","on","off","handleReset","initialTiles","initialMines","initialMistakeCounts","initialMineCount","resetHandler","revealedNonMineTiles","filter","tile","i","length","totalNonMineTiles","mine","children","fileName","_jsxFileName","lineNumber","columnNumber","onTileClick","onReset","_c","$RefreshReg$"],"sources":["/Users/yashwantmoharil/Desktop/football-battlegrounds/client/src/Components/JoinTicTacToe.jsx"],"sourcesContent":["import React, { useEffect, useState } from \"react\"; // Added useState\nimport { useChannelStateContext, useChatContext } from \"stream-chat-react\";\nimport Board from \"./Board\";\nimport GameOver from \"./GameOver\";\nimport GameState from \"./GameState\";\nimport Reset from \"./Reset\";\nimport Mines from \"./Mines\";\n\n\nfunction TicTacToe() {\n  const player = \"X\"; // This seems to be a fixed player for the local client. In a real multi-player game, you'd determine this dynamically.\n  const [turn, setTurn] = useState(\"X\");\n  const [mistakeCounts, setMistakeCounts] = useState({\n    \"X\": 0,\n    \"O\": 0\n  });\n  const { channel } = useChannelStateContext();\n  const { client } = useChatContext();\n  const [tiles, setTiles] = useState(Array(64).fill(null));\n  const [mines, setMines] = useState(Array(64).fill(null));\n  const [mineCount, setMineCount] = useState(5);\n  const [strike, setStrike] = useState(null);\n  const [gameState, setGameState] = useState(GameState.mineCreation);\n\n  // Initial mine creation - runs once when component mounts\n  useEffect(() => {\n    if (gameState === GameState.mineCreation) {\n      let newGrid = Mines(mineCount);\n      setMines(newGrid);\n      setGameState(GameState.start);\n    }\n  }, [gameState, mineCount]); // Dependency on gameState to ensure it runs when mineCreation state is active\n\n  const handleTileclick = async (index) => {\n    if (gameState !== GameState.start && gameState !== GameState.inProgress) return;\n    if (tiles[index] !== null) return; // Prevent clicking on an already revealed tile\n\n    const newTiles = [...tiles];\n    newTiles[index] = mines[index]; // Reveal the tile\n\n    let newMineCount = mineCount;\n    const newMistakeCounts = { ...mistakeCounts };\n    let newTurn = turn === 'X' ? 'O' : 'X';\n    let newGameState = GameState.inProgress;\n\n    if (newTiles[index] === -1) { // If it's a mine\n      newMineCount = mineCount - 1;\n      newMistakeCounts[turn] = newMistakeCounts[turn] + 1; // Increment mistake for the current player\n      if (newMineCount === 0) {\n        newGameState = GameState.gameover; // All mines found\n      }\n    }\n\n    // Update local state immediately\n    setTiles(newTiles);\n    setMineCount(newMineCount);\n    setMistakeCounts(newMistakeCounts);\n    setTurn(newTurn);\n    setGameState(newGameState);\n\n    // Send the updated state to other clients\n    await channel.sendEvent({\n      type: \"game-move\",\n      data: {\n        tiles: newTiles,\n        mines: mines, // Mines array doesn't change after initial creation, so current `mines` is fine\n        turn: newTurn,\n        mineCount: newMineCount,\n        mistakeCounts: newMistakeCounts,\n        gameState: newGameState,\n      }\n    });\n  };\n\n  // Effect to listen for game-move events from other players\n  useEffect(() => {\n    const handler = (event) => {\n      // Only process events from other users\n      if (event.type === \"game-move\" && event.user.id !== client.userID) {\n        // Apply the synced state from the event data\n        setTiles(event.data.tiles);\n        setMines(event.data.mines);\n        setTurn(event.data.turn);\n        setMineCount(event.data.mineCount);\n        setMistakeCounts(event.data.mistakeCounts);\n        setGameState(event.data.gameState);\n      }\n    };\n\n    channel.on(\"event\", handler);\n\n    // Cleanup: remove the event listener when the component unmounts\n    return () => channel.off(\"event\", handler);\n  }, [channel, client.userID]); // Dependencies: channel and client.userID\n\n  const handleReset = async () => { // Make handleReset async to send event\n    const initialTiles = Array(64).fill(null);\n    const initialMines = Mines(5); // Regenerate mines for a new game\n    const initialMistakeCounts = { \"X\": 0, \"O\": 0 };\n    const initialMineCount = 5;\n\n    setTiles(initialTiles);\n    setMines(initialMines); // Set new mines\n    setTurn(\"X\");\n    setMistakeCounts(initialMistakeCounts);\n    setMineCount(initialMineCount);\n    setGameState(GameState.start); // Back to start after reset\n    setStrike(null); // Clear any strike indicator\n\n    // Send reset event to other clients\n    await channel.sendEvent({\n      type: \"game-reset\",\n      data: {\n        tiles: initialTiles,\n        mines: initialMines,\n        turn: \"X\",\n        mineCount: initialMineCount,\n        mistakeCounts: initialMistakeCounts,\n        gameState: GameState.start,\n        strike: null,\n      }\n    });\n  };\n\n  // Add an effect to listen for game-reset events\n  useEffect(() => {\n    const resetHandler = (event) => {\n      if (event.type === \"game-reset\" && event.user.id !== client.userID) {\n        setTiles(event.data.tiles);\n        setMines(event.data.mines);\n        setTurn(event.data.turn);\n        setMineCount(event.data.mineCount);\n        setMistakeCounts(event.data.mistakeCounts);\n        setGameState(event.data.gameState);\n        setStrike(event.data.strike);\n      }\n    };\n\n    channel.on(\"event\", resetHandler);\n    return () => channel.off(\"event\", resetHandler);\n  }, [channel, client.userID]);\n\n\n  // `checkWinner` logic for Tic-Tac-Toe doesn't directly apply to Minesweeper.\n  // In Minesweeper, the game ends when all non-mine tiles are revealed or all mines are found.\n  // Your `checkWinner` currently only checks for a full board.\n  // You might want to rename this or adjust its logic to fit Minesweeper's win/loss conditions.\n  useEffect(() => {\n    // This part should be re-evaluated for Minesweeper's win/loss conditions.\n    // A Tic-Tac-Toe \"tie\" doesn't quite fit here.\n    // If you want to check if all non-mine tiles are revealed for a win, you'd iterate through tiles\n    // and check if all non-mine tiles (mines[i] !== -1) have been revealed (tiles[i] !== null).\n    const revealedNonMineTiles = tiles.filter((tile, i) => tile !== null && mines[i] !== -1).length;\n    const totalNonMineTiles = mines.filter(mine => mine !== -1).length;\n\n    if (gameState === GameState.inProgress && revealedNonMineTiles === totalNonMineTiles) {\n      setGameState(GameState.gameover); // Or GameState.win if you have one\n      // You might want to determine a winner here based on mistake counts or just declare a team win\n    }\n\n  }, [tiles, mines, gameState]); // Dependencies for checking win condition\n\n  return (\n    <div>\n      <h1>Minesweeper Tic-Tac-Toe (Hybrid)</h1>\n      <h4>Current Turn: {turn}</h4>\n      <h4>Mistakes: X: {mistakeCounts[\"X\"]}, O: {mistakeCounts[\"O\"]}</h4>\n      <h4>Mines Remaining: {mineCount}</h4>\n      <Board\n        player={player}\n        tiles={tiles}\n        onTileClick={handleTileclick}\n        strike={strike}\n      />\n      <GameOver gameState={gameState} />\n      <Reset gameState={gameState} onReset={handleReset} />\n    </div>\n  );\n}\n\nexport default TicTacToe;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}