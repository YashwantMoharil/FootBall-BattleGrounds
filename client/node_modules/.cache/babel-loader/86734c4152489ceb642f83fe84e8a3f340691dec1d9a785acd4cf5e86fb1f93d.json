{"ast":null,"code":"import { useCallback, useEffect, useState } from 'react';\n/**\n * Controls the logic when an `UnreadMessagesNotification` component should be shown.\n * In virtualized message list there is no notion of being scrolled below or above `UnreadMessagesSeparator`.\n * Therefore, the `UnreadMessagesNotification` component is rendered based on timestamps.\n * If the there are unread messages in the channel and the `VirtualizedMessageList` renders\n * messages created later than the last read message in the channel, then the\n * `UnreadMessagesNotification` component is rendered. This is an approximate equivalent to being\n * scrolled below the `UnreadMessagesNotification` component.\n * @param lastRead\n * @param showAlways\n * @param unreadCount\n */\nexport const useUnreadMessagesNotificationVirtualized = ({\n  lastRead,\n  showAlways,\n  unreadCount\n}) => {\n  const [show, setShow] = useState(false);\n  const toggleShowUnreadMessagesNotification = useCallback(renderedMessages => {\n    if (!unreadCount) return;\n    const firstRenderedMessage = renderedMessages[0];\n    const lastRenderedMessage = renderedMessages.slice(-1)[0];\n    if (!(firstRenderedMessage && lastRenderedMessage)) return;\n    const firstRenderedMessageTime = new Date(firstRenderedMessage.created_at ?? 0).getTime();\n    const lastRenderedMessageTime = new Date(lastRenderedMessage.created_at ?? 0).getTime();\n    const lastReadTime = new Date(lastRead ?? 0).getTime();\n    const scrolledBelowSeparator = !!lastReadTime && firstRenderedMessageTime > lastReadTime;\n    const scrolledAboveSeparator = !!lastReadTime && lastRenderedMessageTime < lastReadTime;\n    setShow(showAlways ? scrolledBelowSeparator || scrolledAboveSeparator : scrolledBelowSeparator);\n  }, [lastRead, showAlways, unreadCount]);\n  useEffect(() => {\n    if (!unreadCount) setShow(false);\n  }, [unreadCount]);\n  return {\n    show,\n    toggleShowUnreadMessagesNotification\n  };\n};","map":{"version":3,"names":["useCallback","useEffect","useState","useUnreadMessagesNotificationVirtualized","lastRead","showAlways","unreadCount","show","setShow","toggleShowUnreadMessagesNotification","renderedMessages","firstRenderedMessage","lastRenderedMessage","slice","firstRenderedMessageTime","Date","created_at","getTime","lastRenderedMessageTime","lastReadTime","scrolledBelowSeparator","scrolledAboveSeparator"],"sources":["/Users/yashwantmoharil/Desktop/football-battlegrounds/client/node_modules/stream-chat-react/dist/components/MessageList/hooks/VirtualizedMessageList/useUnreadMessagesNotificationVirtualized.js"],"sourcesContent":["import { useCallback, useEffect, useState } from 'react';\n/**\n * Controls the logic when an `UnreadMessagesNotification` component should be shown.\n * In virtualized message list there is no notion of being scrolled below or above `UnreadMessagesSeparator`.\n * Therefore, the `UnreadMessagesNotification` component is rendered based on timestamps.\n * If the there are unread messages in the channel and the `VirtualizedMessageList` renders\n * messages created later than the last read message in the channel, then the\n * `UnreadMessagesNotification` component is rendered. This is an approximate equivalent to being\n * scrolled below the `UnreadMessagesNotification` component.\n * @param lastRead\n * @param showAlways\n * @param unreadCount\n */\nexport const useUnreadMessagesNotificationVirtualized = ({ lastRead, showAlways, unreadCount, }) => {\n    const [show, setShow] = useState(false);\n    const toggleShowUnreadMessagesNotification = useCallback((renderedMessages) => {\n        if (!unreadCount)\n            return;\n        const firstRenderedMessage = renderedMessages[0];\n        const lastRenderedMessage = renderedMessages.slice(-1)[0];\n        if (!(firstRenderedMessage && lastRenderedMessage))\n            return;\n        const firstRenderedMessageTime = new Date(firstRenderedMessage.created_at ?? 0).getTime();\n        const lastRenderedMessageTime = new Date(lastRenderedMessage.created_at ?? 0).getTime();\n        const lastReadTime = new Date(lastRead ?? 0).getTime();\n        const scrolledBelowSeparator = !!lastReadTime && firstRenderedMessageTime > lastReadTime;\n        const scrolledAboveSeparator = !!lastReadTime && lastRenderedMessageTime < lastReadTime;\n        setShow(showAlways\n            ? scrolledBelowSeparator || scrolledAboveSeparator\n            : scrolledBelowSeparator);\n    }, [lastRead, showAlways, unreadCount]);\n    useEffect(() => {\n        if (!unreadCount)\n            setShow(false);\n    }, [unreadCount]);\n    return { show, toggleShowUnreadMessagesNotification };\n};\n"],"mappings":"AAAA,SAASA,WAAW,EAAEC,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,wCAAwC,GAAGA,CAAC;EAAEC,QAAQ;EAAEC,UAAU;EAAEC;AAAa,CAAC,KAAK;EAChG,MAAM,CAACC,IAAI,EAAEC,OAAO,CAAC,GAAGN,QAAQ,CAAC,KAAK,CAAC;EACvC,MAAMO,oCAAoC,GAAGT,WAAW,CAAEU,gBAAgB,IAAK;IAC3E,IAAI,CAACJ,WAAW,EACZ;IACJ,MAAMK,oBAAoB,GAAGD,gBAAgB,CAAC,CAAC,CAAC;IAChD,MAAME,mBAAmB,GAAGF,gBAAgB,CAACG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACzD,IAAI,EAAEF,oBAAoB,IAAIC,mBAAmB,CAAC,EAC9C;IACJ,MAAME,wBAAwB,GAAG,IAAIC,IAAI,CAACJ,oBAAoB,CAACK,UAAU,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;IACzF,MAAMC,uBAAuB,GAAG,IAAIH,IAAI,CAACH,mBAAmB,CAACI,UAAU,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;IACvF,MAAME,YAAY,GAAG,IAAIJ,IAAI,CAACX,QAAQ,IAAI,CAAC,CAAC,CAACa,OAAO,CAAC,CAAC;IACtD,MAAMG,sBAAsB,GAAG,CAAC,CAACD,YAAY,IAAIL,wBAAwB,GAAGK,YAAY;IACxF,MAAME,sBAAsB,GAAG,CAAC,CAACF,YAAY,IAAID,uBAAuB,GAAGC,YAAY;IACvFX,OAAO,CAACH,UAAU,GACZe,sBAAsB,IAAIC,sBAAsB,GAChDD,sBAAsB,CAAC;EACjC,CAAC,EAAE,CAAChB,QAAQ,EAAEC,UAAU,EAAEC,WAAW,CAAC,CAAC;EACvCL,SAAS,CAAC,MAAM;IACZ,IAAI,CAACK,WAAW,EACZE,OAAO,CAAC,KAAK,CAAC;EACtB,CAAC,EAAE,CAACF,WAAW,CAAC,CAAC;EACjB,OAAO;IAAEC,IAAI;IAAEE;EAAqC,CAAC;AACzD,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}