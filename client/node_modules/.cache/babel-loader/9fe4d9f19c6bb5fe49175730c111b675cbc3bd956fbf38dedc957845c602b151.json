{"ast":null,"code":"import React, { useEffect, useRef, useState } from 'react';\nimport { deprecationAndReplacementWarning } from '../../utils/deprecationWarning';\nimport { DEFAULT_LOAD_PAGE_SCROLL_THRESHOLD } from '../../constants/limits';\n/**\n * Prevents Chrome hangups\n * See: https://stackoverflow.com/questions/47524205/random-high-content-download-time-in-chrome/47684257#47684257\n */\nconst mousewheelListener = event => {\n  if (event instanceof WheelEvent && event.deltaY === 1) {\n    event.preventDefault();\n  }\n};\n/**\n * This component serves a single purpose - load more items on scroll inside the MessageList component\n * It is not a general purpose infinite scroll controller, because:\n * 1. It is re-rendered whenever queryInProgress, hasNext, hasPrev changes. This can lead to scrollListener to have stale data.\n * 2. It pretends to invoke scrollListener on resize event even though this event is emitted only on window resize. It should\n * rather use ResizeObserver. But then again, it ResizeObserver would invoke a stale version of scrollListener.\n *\n * In general, the infinite scroll controller should not aim for checking the loading state and whether there is more data to load.\n * That should be controlled by the loading function.\n */\nexport const InfiniteScroll = props => {\n  const {\n    children,\n    element: Component = 'div',\n    hasMore,\n    hasMoreNewer,\n    hasNextPage,\n    hasPreviousPage,\n    head,\n    initialLoad = true,\n    isLoading,\n    listenToScroll,\n    loader,\n    loadMore,\n    loadMoreNewer,\n    loadNextPage,\n    loadPreviousPage,\n    threshold = DEFAULT_LOAD_PAGE_SCROLL_THRESHOLD,\n    useCapture = false,\n    ...elementProps\n  } = props;\n  const loadNextPageFn = loadNextPage || loadMoreNewer;\n  const loadPreviousPageFn = loadPreviousPage || loadMore;\n  const hasNextPageFlag = hasNextPage || hasMoreNewer;\n  const hasPreviousPageFlag = hasPreviousPage || hasMore;\n  const [scrollComponent, setScrollComponent] = useState(null);\n  const previousOffset = useRef(undefined);\n  const previousReverseOffset = useRef(undefined);\n  const scrollListenerRef = useRef(undefined);\n  scrollListenerRef.current = () => {\n    const element = scrollComponent;\n    if (!element || element.offsetParent === null) {\n      return;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const parentElement = element.parentElement;\n    const offset = element.scrollHeight - parentElement.scrollTop - parentElement.clientHeight;\n    const reverseOffset = parentElement.scrollTop;\n    if (listenToScroll) {\n      listenToScroll(offset, reverseOffset, threshold);\n    }\n    if (isLoading) return;\n    if (previousOffset.current === offset && previousReverseOffset.current === reverseOffset) return;\n    previousOffset.current = offset;\n    previousReverseOffset.current = reverseOffset;\n    // FIXME: this triggers loadMore call when a user types messages in thread and the scroll container expands\n    if (reverseOffset < Number(threshold) && typeof loadPreviousPageFn === 'function' && hasPreviousPageFlag) {\n      loadPreviousPageFn();\n    }\n    if (offset < Number(threshold) && typeof loadNextPageFn === 'function' && hasNextPageFlag) {\n      loadNextPageFn();\n    }\n  };\n  useEffect(() => {\n    deprecationAndReplacementWarning([[{\n      hasMoreNewer\n    }, {\n      hasNextPage\n    }], [{\n      loadMoreNewer\n    }, {\n      loadNextPage\n    }], [{\n      hasMore\n    }, {\n      hasPreviousPage\n    }], [{\n      loadMore\n    }, {\n      loadPreviousPage\n    }]], 'InfiniteScroll');\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  useEffect(() => {\n    const scrollElement = scrollComponent?.parentNode;\n    if (!scrollElement) return;\n    const scrollListener = () => scrollListenerRef.current?.();\n    scrollElement.addEventListener('scroll', scrollListener, useCapture);\n    scrollElement.addEventListener('resize', scrollListener, useCapture);\n    scrollListener();\n    return () => {\n      scrollElement.removeEventListener('scroll', scrollListener, useCapture);\n      scrollElement.removeEventListener('resize', scrollListener, useCapture);\n    };\n  }, [initialLoad, scrollComponent, useCapture]);\n  useEffect(() => {\n    const scrollElement = scrollComponent?.parentNode;\n    if (!scrollElement) return;\n    scrollElement.addEventListener('wheel', mousewheelListener, {\n      passive: false\n    });\n    return () => {\n      scrollElement.removeEventListener('wheel', mousewheelListener, useCapture);\n    };\n  }, [scrollComponent, useCapture]);\n  return React.createElement(Component, {\n    ...elementProps,\n    ref: setScrollComponent\n  }, head, loader, children);\n};","map":{"version":3,"names":["React","useEffect","useRef","useState","deprecationAndReplacementWarning","DEFAULT_LOAD_PAGE_SCROLL_THRESHOLD","mousewheelListener","event","WheelEvent","deltaY","preventDefault","InfiniteScroll","props","children","element","Component","hasMore","hasMoreNewer","hasNextPage","hasPreviousPage","head","initialLoad","isLoading","listenToScroll","loader","loadMore","loadMoreNewer","loadNextPage","loadPreviousPage","threshold","useCapture","elementProps","loadNextPageFn","loadPreviousPageFn","hasNextPageFlag","hasPreviousPageFlag","scrollComponent","setScrollComponent","previousOffset","undefined","previousReverseOffset","scrollListenerRef","current","offsetParent","parentElement","offset","scrollHeight","scrollTop","clientHeight","reverseOffset","Number","scrollElement","parentNode","scrollListener","addEventListener","removeEventListener","passive","createElement","ref"],"sources":["/Users/yashwantmoharil/Documents/Football-Battlegrounds/client/node_modules/stream-chat-react/dist/components/InfiniteScrollPaginator/InfiniteScroll.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport { deprecationAndReplacementWarning } from '../../utils/deprecationWarning';\nimport { DEFAULT_LOAD_PAGE_SCROLL_THRESHOLD } from '../../constants/limits';\n/**\n * Prevents Chrome hangups\n * See: https://stackoverflow.com/questions/47524205/random-high-content-download-time-in-chrome/47684257#47684257\n */\nconst mousewheelListener = (event) => {\n    if (event instanceof WheelEvent && event.deltaY === 1) {\n        event.preventDefault();\n    }\n};\n/**\n * This component serves a single purpose - load more items on scroll inside the MessageList component\n * It is not a general purpose infinite scroll controller, because:\n * 1. It is re-rendered whenever queryInProgress, hasNext, hasPrev changes. This can lead to scrollListener to have stale data.\n * 2. It pretends to invoke scrollListener on resize event even though this event is emitted only on window resize. It should\n * rather use ResizeObserver. But then again, it ResizeObserver would invoke a stale version of scrollListener.\n *\n * In general, the infinite scroll controller should not aim for checking the loading state and whether there is more data to load.\n * That should be controlled by the loading function.\n */\nexport const InfiniteScroll = (props) => {\n    const { children, element: Component = 'div', hasMore, hasMoreNewer, hasNextPage, hasPreviousPage, head, initialLoad = true, isLoading, listenToScroll, loader, loadMore, loadMoreNewer, loadNextPage, loadPreviousPage, threshold = DEFAULT_LOAD_PAGE_SCROLL_THRESHOLD, useCapture = false, ...elementProps } = props;\n    const loadNextPageFn = loadNextPage || loadMoreNewer;\n    const loadPreviousPageFn = loadPreviousPage || loadMore;\n    const hasNextPageFlag = hasNextPage || hasMoreNewer;\n    const hasPreviousPageFlag = hasPreviousPage || hasMore;\n    const [scrollComponent, setScrollComponent] = useState(null);\n    const previousOffset = useRef(undefined);\n    const previousReverseOffset = useRef(undefined);\n    const scrollListenerRef = useRef(undefined);\n    scrollListenerRef.current = () => {\n        const element = scrollComponent;\n        if (!element || element.offsetParent === null) {\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const parentElement = element.parentElement;\n        const offset = element.scrollHeight - parentElement.scrollTop - parentElement.clientHeight;\n        const reverseOffset = parentElement.scrollTop;\n        if (listenToScroll) {\n            listenToScroll(offset, reverseOffset, threshold);\n        }\n        if (isLoading)\n            return;\n        if (previousOffset.current === offset &&\n            previousReverseOffset.current === reverseOffset)\n            return;\n        previousOffset.current = offset;\n        previousReverseOffset.current = reverseOffset;\n        // FIXME: this triggers loadMore call when a user types messages in thread and the scroll container expands\n        if (reverseOffset < Number(threshold) &&\n            typeof loadPreviousPageFn === 'function' &&\n            hasPreviousPageFlag) {\n            loadPreviousPageFn();\n        }\n        if (offset < Number(threshold) &&\n            typeof loadNextPageFn === 'function' &&\n            hasNextPageFlag) {\n            loadNextPageFn();\n        }\n    };\n    useEffect(() => {\n        deprecationAndReplacementWarning([\n            [{ hasMoreNewer }, { hasNextPage }],\n            [{ loadMoreNewer }, { loadNextPage }],\n            [{ hasMore }, { hasPreviousPage }],\n            [{ loadMore }, { loadPreviousPage }],\n        ], 'InfiniteScroll');\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    useEffect(() => {\n        const scrollElement = scrollComponent?.parentNode;\n        if (!scrollElement)\n            return;\n        const scrollListener = () => scrollListenerRef.current?.();\n        scrollElement.addEventListener('scroll', scrollListener, useCapture);\n        scrollElement.addEventListener('resize', scrollListener, useCapture);\n        scrollListener();\n        return () => {\n            scrollElement.removeEventListener('scroll', scrollListener, useCapture);\n            scrollElement.removeEventListener('resize', scrollListener, useCapture);\n        };\n    }, [initialLoad, scrollComponent, useCapture]);\n    useEffect(() => {\n        const scrollElement = scrollComponent?.parentNode;\n        if (!scrollElement)\n            return;\n        scrollElement.addEventListener('wheel', mousewheelListener, { passive: false });\n        return () => {\n            scrollElement.removeEventListener('wheel', mousewheelListener, useCapture);\n        };\n    }, [scrollComponent, useCapture]);\n    return (React.createElement(Component, { ...elementProps, ref: setScrollComponent },\n        head,\n        loader,\n        children));\n};\n"],"mappings":"AAAA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAC1D,SAASC,gCAAgC,QAAQ,gCAAgC;AACjF,SAASC,kCAAkC,QAAQ,wBAAwB;AAC3E;AACA;AACA;AACA;AACA,MAAMC,kBAAkB,GAAIC,KAAK,IAAK;EAClC,IAAIA,KAAK,YAAYC,UAAU,IAAID,KAAK,CAACE,MAAM,KAAK,CAAC,EAAE;IACnDF,KAAK,CAACG,cAAc,CAAC,CAAC;EAC1B;AACJ,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,cAAc,GAAIC,KAAK,IAAK;EACrC,MAAM;IAAEC,QAAQ;IAAEC,OAAO,EAAEC,SAAS,GAAG,KAAK;IAAEC,OAAO;IAAEC,YAAY;IAAEC,WAAW;IAAEC,eAAe;IAAEC,IAAI;IAAEC,WAAW,GAAG,IAAI;IAAEC,SAAS;IAAEC,cAAc;IAAEC,MAAM;IAAEC,QAAQ;IAAEC,aAAa;IAAEC,YAAY;IAAEC,gBAAgB;IAAEC,SAAS,GAAGxB,kCAAkC;IAAEyB,UAAU,GAAG,KAAK;IAAE,GAAGC;EAAa,CAAC,GAAGnB,KAAK;EACtT,MAAMoB,cAAc,GAAGL,YAAY,IAAID,aAAa;EACpD,MAAMO,kBAAkB,GAAGL,gBAAgB,IAAIH,QAAQ;EACvD,MAAMS,eAAe,GAAGhB,WAAW,IAAID,YAAY;EACnD,MAAMkB,mBAAmB,GAAGhB,eAAe,IAAIH,OAAO;EACtD,MAAM,CAACoB,eAAe,EAAEC,kBAAkB,CAAC,GAAGlC,QAAQ,CAAC,IAAI,CAAC;EAC5D,MAAMmC,cAAc,GAAGpC,MAAM,CAACqC,SAAS,CAAC;EACxC,MAAMC,qBAAqB,GAAGtC,MAAM,CAACqC,SAAS,CAAC;EAC/C,MAAME,iBAAiB,GAAGvC,MAAM,CAACqC,SAAS,CAAC;EAC3CE,iBAAiB,CAACC,OAAO,GAAG,MAAM;IAC9B,MAAM5B,OAAO,GAAGsB,eAAe;IAC/B,IAAI,CAACtB,OAAO,IAAIA,OAAO,CAAC6B,YAAY,KAAK,IAAI,EAAE;MAC3C;IACJ;IACA;IACA,MAAMC,aAAa,GAAG9B,OAAO,CAAC8B,aAAa;IAC3C,MAAMC,MAAM,GAAG/B,OAAO,CAACgC,YAAY,GAAGF,aAAa,CAACG,SAAS,GAAGH,aAAa,CAACI,YAAY;IAC1F,MAAMC,aAAa,GAAGL,aAAa,CAACG,SAAS;IAC7C,IAAIxB,cAAc,EAAE;MAChBA,cAAc,CAACsB,MAAM,EAAEI,aAAa,EAAEpB,SAAS,CAAC;IACpD;IACA,IAAIP,SAAS,EACT;IACJ,IAAIgB,cAAc,CAACI,OAAO,KAAKG,MAAM,IACjCL,qBAAqB,CAACE,OAAO,KAAKO,aAAa,EAC/C;IACJX,cAAc,CAACI,OAAO,GAAGG,MAAM;IAC/BL,qBAAqB,CAACE,OAAO,GAAGO,aAAa;IAC7C;IACA,IAAIA,aAAa,GAAGC,MAAM,CAACrB,SAAS,CAAC,IACjC,OAAOI,kBAAkB,KAAK,UAAU,IACxCE,mBAAmB,EAAE;MACrBF,kBAAkB,CAAC,CAAC;IACxB;IACA,IAAIY,MAAM,GAAGK,MAAM,CAACrB,SAAS,CAAC,IAC1B,OAAOG,cAAc,KAAK,UAAU,IACpCE,eAAe,EAAE;MACjBF,cAAc,CAAC,CAAC;IACpB;EACJ,CAAC;EACD/B,SAAS,CAAC,MAAM;IACZG,gCAAgC,CAAC,CAC7B,CAAC;MAAEa;IAAa,CAAC,EAAE;MAAEC;IAAY,CAAC,CAAC,EACnC,CAAC;MAAEQ;IAAc,CAAC,EAAE;MAAEC;IAAa,CAAC,CAAC,EACrC,CAAC;MAAEX;IAAQ,CAAC,EAAE;MAAEG;IAAgB,CAAC,CAAC,EAClC,CAAC;MAAEM;IAAS,CAAC,EAAE;MAAEG;IAAiB,CAAC,CAAC,CACvC,EAAE,gBAAgB,CAAC;IACpB;EACJ,CAAC,EAAE,EAAE,CAAC;EACN3B,SAAS,CAAC,MAAM;IACZ,MAAMkD,aAAa,GAAGf,eAAe,EAAEgB,UAAU;IACjD,IAAI,CAACD,aAAa,EACd;IACJ,MAAME,cAAc,GAAGA,CAAA,KAAMZ,iBAAiB,CAACC,OAAO,GAAG,CAAC;IAC1DS,aAAa,CAACG,gBAAgB,CAAC,QAAQ,EAAED,cAAc,EAAEvB,UAAU,CAAC;IACpEqB,aAAa,CAACG,gBAAgB,CAAC,QAAQ,EAAED,cAAc,EAAEvB,UAAU,CAAC;IACpEuB,cAAc,CAAC,CAAC;IAChB,OAAO,MAAM;MACTF,aAAa,CAACI,mBAAmB,CAAC,QAAQ,EAAEF,cAAc,EAAEvB,UAAU,CAAC;MACvEqB,aAAa,CAACI,mBAAmB,CAAC,QAAQ,EAAEF,cAAc,EAAEvB,UAAU,CAAC;IAC3E,CAAC;EACL,CAAC,EAAE,CAACT,WAAW,EAAEe,eAAe,EAAEN,UAAU,CAAC,CAAC;EAC9C7B,SAAS,CAAC,MAAM;IACZ,MAAMkD,aAAa,GAAGf,eAAe,EAAEgB,UAAU;IACjD,IAAI,CAACD,aAAa,EACd;IACJA,aAAa,CAACG,gBAAgB,CAAC,OAAO,EAAEhD,kBAAkB,EAAE;MAAEkD,OAAO,EAAE;IAAM,CAAC,CAAC;IAC/E,OAAO,MAAM;MACTL,aAAa,CAACI,mBAAmB,CAAC,OAAO,EAAEjD,kBAAkB,EAAEwB,UAAU,CAAC;IAC9E,CAAC;EACL,CAAC,EAAE,CAACM,eAAe,EAAEN,UAAU,CAAC,CAAC;EACjC,OAAQ9B,KAAK,CAACyD,aAAa,CAAC1C,SAAS,EAAE;IAAE,GAAGgB,YAAY;IAAE2B,GAAG,EAAErB;EAAmB,CAAC,EAC/EjB,IAAI,EACJI,MAAM,EACNX,QAAQ,CAAC;AACjB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}