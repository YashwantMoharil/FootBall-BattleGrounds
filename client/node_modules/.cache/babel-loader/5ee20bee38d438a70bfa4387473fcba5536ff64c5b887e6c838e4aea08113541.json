{"ast":null,"code":"import { useCallback, useEffect, useMemo, useRef } from 'react';\nimport { extractSortValue, findLastPinnedChannelIndex, isChannelArchived, isChannelPinned, moveChannelUpwards, shouldConsiderArchivedChannels, shouldConsiderPinnedChannels } from '../utils';\nimport { useChatContext } from '../../../context';\nimport { getChannel } from '../../../utils';\nconst shared = ({\n  customHandler,\n  event,\n  setChannels\n}) => {\n  if (typeof customHandler === 'function') {\n    return customHandler(setChannels, event);\n  }\n  setChannels(channels => {\n    const channelIndex = channels.findIndex(channel => channel.cid === event.cid);\n    if (channelIndex < 0) return channels;\n    channels.splice(channelIndex, 1);\n    return [...channels];\n  });\n};\nexport const useChannelListShapeDefaults = () => {\n  const {\n    client\n  } = useChatContext();\n  const handleMessageNew = useCallback(({\n    allowNewMessagesFromUnfilteredChannels,\n    customHandler,\n    event,\n    filters,\n    lockChannelOrder,\n    setChannels,\n    sort\n  }) => {\n    if (typeof customHandler === 'function') {\n      return customHandler(setChannels, event);\n    }\n    const channelType = event.channel_type;\n    const channelId = event.channel_id;\n    if (!channelType || !channelId) return;\n    setChannels(currentChannels => {\n      const targetChannel = client.channel(channelType, channelId);\n      const targetChannelIndex = currentChannels.indexOf(targetChannel);\n      const targetChannelExistsWithinList = targetChannelIndex >= 0;\n      const isTargetChannelPinned = isChannelPinned(targetChannel);\n      const isTargetChannelArchived = isChannelArchived(targetChannel);\n      const considerArchivedChannels = shouldConsiderArchivedChannels(filters);\n      const considerPinnedChannels = shouldConsiderPinnedChannels(sort);\n      if (\n      // filter is defined, target channel is archived and filter option is set to false\n      considerArchivedChannels && isTargetChannelArchived && !filters.archived ||\n      // filter is defined, target channel isn't archived and filter option is set to true\n      considerArchivedChannels && !isTargetChannelArchived && filters.archived ||\n      // sort option is defined, target channel is pinned\n      considerPinnedChannels && isTargetChannelPinned ||\n      // list order is locked\n      lockChannelOrder ||\n      // target channel is not within the loaded list and loading from cache is disallowed\n      !targetChannelExistsWithinList && !allowNewMessagesFromUnfilteredChannels) {\n        return currentChannels;\n      }\n      return moveChannelUpwards({\n        channels: currentChannels,\n        channelToMove: targetChannel,\n        channelToMoveIndexWithinChannels: targetChannelIndex,\n        sort\n      });\n    });\n  }, [client]);\n  const handleNotificationMessageNew = useCallback(async ({\n    allowNewMessagesFromUnfilteredChannels,\n    customHandler,\n    event,\n    filters,\n    setChannels,\n    sort\n  }) => {\n    if (typeof customHandler === 'function') {\n      return customHandler(setChannels, event);\n    }\n    if (!event.channel) {\n      return;\n    }\n    const channel = await getChannel({\n      client,\n      id: event.channel.id,\n      type: event.channel.type\n    });\n    const considerArchivedChannels = shouldConsiderArchivedChannels(filters);\n    if (isChannelArchived(channel) && considerArchivedChannels && !filters.archived) {\n      return;\n    }\n    if (!allowNewMessagesFromUnfilteredChannels) {\n      return;\n    }\n    setChannels(channels => moveChannelUpwards({\n      channels,\n      channelToMove: channel,\n      sort\n    }));\n  }, [client]);\n  const handleNotificationAddedToChannel = useCallback(async ({\n    allowNewMessagesFromUnfilteredChannels,\n    customHandler,\n    event,\n    setChannels,\n    sort\n  }) => {\n    if (typeof customHandler === 'function') {\n      return customHandler(setChannels, event);\n    }\n    if (!event.channel || !allowNewMessagesFromUnfilteredChannels) {\n      return;\n    }\n    const channel = await getChannel({\n      client,\n      id: event.channel.id,\n      members: event.channel.members?.reduce((newMembers, {\n        user,\n        user_id\n      }) => {\n        const userId = user_id || user?.id;\n        if (userId) newMembers.push(userId);\n        return newMembers;\n      }, []),\n      type: event.channel.type\n    });\n    // membership has been reset (target channel shouldn't be pinned nor archived)\n    setChannels(channels => moveChannelUpwards({\n      channels,\n      channelToMove: channel,\n      sort\n    }));\n  }, [client]);\n  const handleNotificationRemovedFromChannel = useCallback(({\n    customHandler,\n    event,\n    setChannels\n  }) => {\n    if (typeof customHandler === 'function') {\n      return customHandler(setChannels, event);\n    }\n    setChannels(channels => channels.filter(channel => channel.cid !== event.channel?.cid));\n  }, []);\n  const handleMemberUpdated = useCallback(({\n    event,\n    filters,\n    lockChannelOrder,\n    setChannels,\n    sort\n  }) => {\n    if (!event.member?.user || event.member.user.id !== client.userID || !event.channel_type) {\n      return;\n    }\n    const channelType = event.channel_type;\n    const channelId = event.channel_id;\n    const considerPinnedChannels = shouldConsiderPinnedChannels(sort);\n    const considerArchivedChannels = shouldConsiderArchivedChannels(filters);\n    // `pinned_at` nor `archived` properties are set or channel list order is locked, return early\n    if (!considerPinnedChannels && !considerArchivedChannels || lockChannelOrder) {\n      return;\n    }\n    const pinnedAtSort = extractSortValue({\n      atIndex: 0,\n      sort,\n      targetKey: 'pinned_at'\n    });\n    setChannels(currentChannels => {\n      const targetChannel = client.channel(channelType, channelId);\n      // assumes that channel instances are not changing\n      const targetChannelIndex = currentChannels.indexOf(targetChannel);\n      const targetChannelExistsWithinList = targetChannelIndex >= 0;\n      const isTargetChannelArchived = isChannelArchived(targetChannel);\n      const isTargetChannelPinned = isChannelPinned(targetChannel);\n      const newChannels = [...currentChannels];\n      if (targetChannelExistsWithinList) {\n        newChannels.splice(targetChannelIndex, 1);\n      }\n      // handle archiving (remove channel)\n      if (considerArchivedChannels && isTargetChannelArchived && !filters.archived || considerArchivedChannels && !isTargetChannelArchived && filters.archived) {\n        return newChannels;\n      }\n      let lastPinnedChannelIndex = null;\n      // calculate last pinned channel index only if `pinned_at` sort is set to\n      // ascending order or if it's in descending order while the pin is being removed, otherwise\n      // we move to the top (index 0)\n      if (pinnedAtSort === 1 || pinnedAtSort === -1 && !isTargetChannelPinned) {\n        lastPinnedChannelIndex = findLastPinnedChannelIndex({\n          channels: newChannels\n        });\n      }\n      const newTargetChannelIndex = typeof lastPinnedChannelIndex === 'number' ? lastPinnedChannelIndex + 1 : 0;\n      // skip re-render if the position of the channel does not change\n      if (currentChannels[newTargetChannelIndex] === targetChannel) {\n        return currentChannels;\n      }\n      newChannels.splice(newTargetChannelIndex, 0, targetChannel);\n      return newChannels;\n    });\n  }, [client]);\n  const handleChannelDeleted = useCallback(p => shared(p), []);\n  const handleChannelHidden = useCallback(p => shared(p), []);\n  const handleChannelVisible = useCallback(async ({\n    customHandler,\n    event,\n    filters,\n    setChannels,\n    sort\n  }) => {\n    if (typeof customHandler === 'function') {\n      return customHandler(setChannels, event);\n    }\n    if (!event.channel_id && !event.channel_type) {\n      return;\n    }\n    const channel = await getChannel({\n      client,\n      id: event.channel_id,\n      type: event.channel_type\n    });\n    const considerArchivedChannels = shouldConsiderArchivedChannels(filters);\n    if (isChannelArchived(channel) && considerArchivedChannels && !filters.archived) {\n      return;\n    }\n    setChannels(channels => moveChannelUpwards({\n      channels,\n      channelToMove: channel,\n      sort\n    }));\n  }, [client]);\n  const handleChannelTruncated = useCallback(({\n    customHandler,\n    event,\n    setChannels\n  }) => {\n    if (typeof customHandler === 'function') {\n      return customHandler(setChannels, event);\n    }\n    // TODO: not sure whether this is needed\n    setChannels(channels => [...channels]);\n    // if (forceUpdate) {\n    //   forceUpdate();\n    // }\n  }, []);\n  const handleChannelUpdated = useCallback(({\n    customHandler,\n    event,\n    setChannels\n  }) => {\n    if (typeof customHandler === 'function') {\n      return customHandler(setChannels, event);\n    }\n    setChannels(channels => {\n      const channelIndex = channels.findIndex(channel => channel.cid === event.channel?.cid);\n      if (channelIndex > -1 && event.channel) {\n        const newChannels = channels;\n        newChannels[channelIndex].data = {\n          ...event.channel,\n          hidden: event.channel?.hidden ?? newChannels[channelIndex].data?.hidden,\n          own_capabilities: event.channel?.own_capabilities ?? newChannels[channelIndex].data?.own_capabilities\n        };\n        return [...newChannels];\n      }\n      return channels;\n    });\n    // if (forceUpdate) {\n    //   forceUpdate();\n    // }\n  }, []);\n  const handleUserPresenceChanged = useCallback(({\n    event,\n    setChannels\n  }) => {\n    setChannels(channels => {\n      const newChannels = channels.map(channel => {\n        if (!event.user?.id || !channel.state.members[event.user.id]) {\n          return channel;\n        }\n        // FIXME: oh no...\n        const newChannel = channel;\n        newChannel.state.members[event.user.id].user = event.user;\n        return newChannel;\n      });\n      return newChannels;\n    });\n  }, []);\n  return useMemo(() => ({\n    handleChannelDeleted,\n    handleChannelHidden,\n    handleChannelTruncated,\n    handleChannelUpdated,\n    handleChannelVisible,\n    handleMemberUpdated,\n    handleMessageNew,\n    handleNotificationAddedToChannel,\n    handleNotificationMessageNew,\n    handleNotificationRemovedFromChannel,\n    handleUserPresenceChanged\n  }), [handleChannelDeleted, handleChannelHidden, handleChannelTruncated, handleChannelUpdated, handleChannelVisible, handleMemberUpdated, handleMessageNew, handleNotificationAddedToChannel, handleNotificationMessageNew, handleNotificationRemovedFromChannel, handleUserPresenceChanged]);\n};\nexport const usePrepareShapeHandlers = ({\n  allowNewMessagesFromUnfilteredChannels,\n  customHandleChannelListShape,\n  filters,\n  lockChannelOrder,\n  onAddedToChannel,\n  onChannelDeleted,\n  onChannelHidden,\n  onChannelTruncated,\n  onChannelUpdated,\n  onChannelVisible,\n  onMessageNew,\n  onMessageNewHandler,\n  onRemovedFromChannel,\n  setChannels,\n  sort\n}) => {\n  const defaults = useChannelListShapeDefaults();\n  const defaultHandleChannelListShapeRef = useRef(undefined);\n  const customHandleChannelListShapeRef = useRef(undefined);\n  customHandleChannelListShapeRef.current = event => {\n    customHandleChannelListShape?.({\n      defaults,\n      event,\n      setChannels\n    });\n  };\n  defaultHandleChannelListShapeRef.current = event => {\n    switch (event.type) {\n      case 'message.new':\n        defaults.handleMessageNew({\n          allowNewMessagesFromUnfilteredChannels,\n          customHandler: onMessageNewHandler,\n          event,\n          filters,\n          lockChannelOrder,\n          setChannels,\n          sort\n        });\n        break;\n      case 'notification.message_new':\n        defaults.handleNotificationMessageNew({\n          allowNewMessagesFromUnfilteredChannels,\n          customHandler: onMessageNew,\n          event,\n          filters,\n          lockChannelOrder,\n          setChannels,\n          sort\n        });\n        break;\n      case 'notification.added_to_channel':\n        defaults.handleNotificationAddedToChannel({\n          allowNewMessagesFromUnfilteredChannels,\n          customHandler: onAddedToChannel,\n          event,\n          lockChannelOrder,\n          setChannels,\n          sort\n        });\n        break;\n      case 'notification.removed_from_channel':\n        defaults.handleNotificationRemovedFromChannel({\n          customHandler: onRemovedFromChannel,\n          event,\n          setChannels\n        });\n        break;\n      case 'channel.deleted':\n        defaults.handleChannelDeleted({\n          customHandler: onChannelDeleted,\n          event,\n          setChannels\n        });\n        break;\n      case 'channel.hidden':\n        defaults.handleChannelHidden({\n          customHandler: onChannelHidden,\n          event,\n          setChannels\n        });\n        break;\n      case 'channel.visible':\n        defaults.handleChannelVisible({\n          customHandler: onChannelVisible,\n          event,\n          filters,\n          setChannels,\n          sort\n        });\n        break;\n      case 'channel.truncated':\n        defaults.handleChannelTruncated({\n          customHandler: onChannelTruncated,\n          event,\n          setChannels\n        });\n        break;\n      case 'channel.updated':\n        defaults.handleChannelUpdated({\n          customHandler: onChannelUpdated,\n          event,\n          setChannels\n        });\n        break;\n      case 'user.presence.changed':\n        defaults.handleUserPresenceChanged({\n          event,\n          setChannels\n        });\n        break;\n      case 'member.updated':\n        defaults.handleMemberUpdated({\n          event,\n          filters,\n          lockChannelOrder,\n          setChannels,\n          sort\n        });\n        break;\n      default:\n        break;\n    }\n  };\n  const defaultFn = useCallback(e => {\n    defaultHandleChannelListShapeRef.current?.(e);\n  }, []);\n  const customFn = useMemo(() => {\n    if (!customHandleChannelListShape) return null;\n    return e => {\n      customHandleChannelListShapeRef.current?.(e);\n    };\n  }, [customHandleChannelListShape]);\n  return {\n    customHandler: customFn,\n    defaultHandler: defaultFn\n  };\n};\nexport const useChannelListShape = handler => {\n  const {\n    client\n  } = useChatContext();\n  useEffect(() => {\n    const subscription = client.on('all', handler);\n    return subscription.unsubscribe;\n  }, [client, handler]);\n};","map":{"version":3,"names":["useCallback","useEffect","useMemo","useRef","extractSortValue","findLastPinnedChannelIndex","isChannelArchived","isChannelPinned","moveChannelUpwards","shouldConsiderArchivedChannels","shouldConsiderPinnedChannels","useChatContext","getChannel","shared","customHandler","event","setChannels","channels","channelIndex","findIndex","channel","cid","splice","useChannelListShapeDefaults","client","handleMessageNew","allowNewMessagesFromUnfilteredChannels","filters","lockChannelOrder","sort","channelType","channel_type","channelId","channel_id","currentChannels","targetChannel","targetChannelIndex","indexOf","targetChannelExistsWithinList","isTargetChannelPinned","isTargetChannelArchived","considerArchivedChannels","considerPinnedChannels","archived","channelToMove","channelToMoveIndexWithinChannels","handleNotificationMessageNew","id","type","handleNotificationAddedToChannel","members","reduce","newMembers","user","user_id","userId","push","handleNotificationRemovedFromChannel","filter","handleMemberUpdated","member","userID","pinnedAtSort","atIndex","targetKey","newChannels","lastPinnedChannelIndex","newTargetChannelIndex","handleChannelDeleted","p","handleChannelHidden","handleChannelVisible","handleChannelTruncated","handleChannelUpdated","data","hidden","own_capabilities","handleUserPresenceChanged","map","state","newChannel","usePrepareShapeHandlers","customHandleChannelListShape","onAddedToChannel","onChannelDeleted","onChannelHidden","onChannelTruncated","onChannelUpdated","onChannelVisible","onMessageNew","onMessageNewHandler","onRemovedFromChannel","defaults","defaultHandleChannelListShapeRef","undefined","customHandleChannelListShapeRef","current","defaultFn","e","customFn","defaultHandler","useChannelListShape","handler","subscription","on","unsubscribe"],"sources":["/Users/yashwantmoharil/Desktop/football-battlegrounds/client/node_modules/stream-chat-react/dist/components/ChannelList/hooks/useChannelListShape.js"],"sourcesContent":["import { useCallback, useEffect, useMemo, useRef } from 'react';\nimport { extractSortValue, findLastPinnedChannelIndex, isChannelArchived, isChannelPinned, moveChannelUpwards, shouldConsiderArchivedChannels, shouldConsiderPinnedChannels, } from '../utils';\nimport { useChatContext } from '../../../context';\nimport { getChannel } from '../../../utils';\nconst shared = ({ customHandler, event, setChannels, }) => {\n    if (typeof customHandler === 'function') {\n        return customHandler(setChannels, event);\n    }\n    setChannels((channels) => {\n        const channelIndex = channels.findIndex((channel) => channel.cid === event.cid);\n        if (channelIndex < 0)\n            return channels;\n        channels.splice(channelIndex, 1);\n        return [...channels];\n    });\n};\nexport const useChannelListShapeDefaults = () => {\n    const { client } = useChatContext();\n    const handleMessageNew = useCallback(({ allowNewMessagesFromUnfilteredChannels, customHandler, event, filters, lockChannelOrder, setChannels, sort, }) => {\n        if (typeof customHandler === 'function') {\n            return customHandler(setChannels, event);\n        }\n        const channelType = event.channel_type;\n        const channelId = event.channel_id;\n        if (!channelType || !channelId)\n            return;\n        setChannels((currentChannels) => {\n            const targetChannel = client.channel(channelType, channelId);\n            const targetChannelIndex = currentChannels.indexOf(targetChannel);\n            const targetChannelExistsWithinList = targetChannelIndex >= 0;\n            const isTargetChannelPinned = isChannelPinned(targetChannel);\n            const isTargetChannelArchived = isChannelArchived(targetChannel);\n            const considerArchivedChannels = shouldConsiderArchivedChannels(filters);\n            const considerPinnedChannels = shouldConsiderPinnedChannels(sort);\n            if (\n            // filter is defined, target channel is archived and filter option is set to false\n            (considerArchivedChannels && isTargetChannelArchived && !filters.archived) ||\n                // filter is defined, target channel isn't archived and filter option is set to true\n                (considerArchivedChannels && !isTargetChannelArchived && filters.archived) ||\n                // sort option is defined, target channel is pinned\n                (considerPinnedChannels && isTargetChannelPinned) ||\n                // list order is locked\n                lockChannelOrder ||\n                // target channel is not within the loaded list and loading from cache is disallowed\n                (!targetChannelExistsWithinList && !allowNewMessagesFromUnfilteredChannels)) {\n                return currentChannels;\n            }\n            return moveChannelUpwards({\n                channels: currentChannels,\n                channelToMove: targetChannel,\n                channelToMoveIndexWithinChannels: targetChannelIndex,\n                sort,\n            });\n        });\n    }, [client]);\n    const handleNotificationMessageNew = useCallback(async ({ allowNewMessagesFromUnfilteredChannels, customHandler, event, filters, setChannels, sort, }) => {\n        if (typeof customHandler === 'function') {\n            return customHandler(setChannels, event);\n        }\n        if (!event.channel) {\n            return;\n        }\n        const channel = await getChannel({\n            client,\n            id: event.channel.id,\n            type: event.channel.type,\n        });\n        const considerArchivedChannels = shouldConsiderArchivedChannels(filters);\n        if (isChannelArchived(channel) && considerArchivedChannels && !filters.archived) {\n            return;\n        }\n        if (!allowNewMessagesFromUnfilteredChannels) {\n            return;\n        }\n        setChannels((channels) => moveChannelUpwards({\n            channels,\n            channelToMove: channel,\n            sort,\n        }));\n    }, [client]);\n    const handleNotificationAddedToChannel = useCallback(async ({ allowNewMessagesFromUnfilteredChannels, customHandler, event, setChannels, sort, }) => {\n        if (typeof customHandler === 'function') {\n            return customHandler(setChannels, event);\n        }\n        if (!event.channel || !allowNewMessagesFromUnfilteredChannels) {\n            return;\n        }\n        const channel = await getChannel({\n            client,\n            id: event.channel.id,\n            members: event.channel.members?.reduce((newMembers, { user, user_id }) => {\n                const userId = user_id || user?.id;\n                if (userId)\n                    newMembers.push(userId);\n                return newMembers;\n            }, []),\n            type: event.channel.type,\n        });\n        // membership has been reset (target channel shouldn't be pinned nor archived)\n        setChannels((channels) => moveChannelUpwards({\n            channels,\n            channelToMove: channel,\n            sort,\n        }));\n    }, [client]);\n    const handleNotificationRemovedFromChannel = useCallback(({ customHandler, event, setChannels, }) => {\n        if (typeof customHandler === 'function') {\n            return customHandler(setChannels, event);\n        }\n        setChannels((channels) => channels.filter((channel) => channel.cid !== event.channel?.cid));\n    }, []);\n    const handleMemberUpdated = useCallback(({ event, filters, lockChannelOrder, setChannels, sort, }) => {\n        if (!event.member?.user ||\n            event.member.user.id !== client.userID ||\n            !event.channel_type) {\n            return;\n        }\n        const channelType = event.channel_type;\n        const channelId = event.channel_id;\n        const considerPinnedChannels = shouldConsiderPinnedChannels(sort);\n        const considerArchivedChannels = shouldConsiderArchivedChannels(filters);\n        // `pinned_at` nor `archived` properties are set or channel list order is locked, return early\n        if ((!considerPinnedChannels && !considerArchivedChannels) || lockChannelOrder) {\n            return;\n        }\n        const pinnedAtSort = extractSortValue({ atIndex: 0, sort, targetKey: 'pinned_at' });\n        setChannels((currentChannels) => {\n            const targetChannel = client.channel(channelType, channelId);\n            // assumes that channel instances are not changing\n            const targetChannelIndex = currentChannels.indexOf(targetChannel);\n            const targetChannelExistsWithinList = targetChannelIndex >= 0;\n            const isTargetChannelArchived = isChannelArchived(targetChannel);\n            const isTargetChannelPinned = isChannelPinned(targetChannel);\n            const newChannels = [...currentChannels];\n            if (targetChannelExistsWithinList) {\n                newChannels.splice(targetChannelIndex, 1);\n            }\n            // handle archiving (remove channel)\n            if ((considerArchivedChannels && isTargetChannelArchived && !filters.archived) ||\n                (considerArchivedChannels && !isTargetChannelArchived && filters.archived)) {\n                return newChannels;\n            }\n            let lastPinnedChannelIndex = null;\n            // calculate last pinned channel index only if `pinned_at` sort is set to\n            // ascending order or if it's in descending order while the pin is being removed, otherwise\n            // we move to the top (index 0)\n            if (pinnedAtSort === 1 || (pinnedAtSort === -1 && !isTargetChannelPinned)) {\n                lastPinnedChannelIndex = findLastPinnedChannelIndex({ channels: newChannels });\n            }\n            const newTargetChannelIndex = typeof lastPinnedChannelIndex === 'number' ? lastPinnedChannelIndex + 1 : 0;\n            // skip re-render if the position of the channel does not change\n            if (currentChannels[newTargetChannelIndex] === targetChannel) {\n                return currentChannels;\n            }\n            newChannels.splice(newTargetChannelIndex, 0, targetChannel);\n            return newChannels;\n        });\n    }, [client]);\n    const handleChannelDeleted = useCallback((p) => shared(p), []);\n    const handleChannelHidden = useCallback((p) => shared(p), []);\n    const handleChannelVisible = useCallback(async ({ customHandler, event, filters, setChannels, sort, }) => {\n        if (typeof customHandler === 'function') {\n            return customHandler(setChannels, event);\n        }\n        if (!event.channel_id && !event.channel_type) {\n            return;\n        }\n        const channel = await getChannel({\n            client,\n            id: event.channel_id,\n            type: event.channel_type,\n        });\n        const considerArchivedChannels = shouldConsiderArchivedChannels(filters);\n        if (isChannelArchived(channel) && considerArchivedChannels && !filters.archived) {\n            return;\n        }\n        setChannels((channels) => moveChannelUpwards({\n            channels,\n            channelToMove: channel,\n            sort,\n        }));\n    }, [client]);\n    const handleChannelTruncated = useCallback(({ customHandler, event, setChannels }) => {\n        if (typeof customHandler === 'function') {\n            return customHandler(setChannels, event);\n        }\n        // TODO: not sure whether this is needed\n        setChannels((channels) => [...channels]);\n        // if (forceUpdate) {\n        //   forceUpdate();\n        // }\n    }, []);\n    const handleChannelUpdated = useCallback(({ customHandler, event, setChannels }) => {\n        if (typeof customHandler === 'function') {\n            return customHandler(setChannels, event);\n        }\n        setChannels((channels) => {\n            const channelIndex = channels.findIndex((channel) => channel.cid === event.channel?.cid);\n            if (channelIndex > -1 && event.channel) {\n                const newChannels = channels;\n                newChannels[channelIndex].data = {\n                    ...event.channel,\n                    hidden: event.channel?.hidden ?? newChannels[channelIndex].data?.hidden,\n                    own_capabilities: event.channel?.own_capabilities ??\n                        newChannels[channelIndex].data?.own_capabilities,\n                };\n                return [...newChannels];\n            }\n            return channels;\n        });\n        // if (forceUpdate) {\n        //   forceUpdate();\n        // }\n    }, []);\n    const handleUserPresenceChanged = useCallback(({ event, setChannels }) => {\n        setChannels((channels) => {\n            const newChannels = channels.map((channel) => {\n                if (!event.user?.id || !channel.state.members[event.user.id]) {\n                    return channel;\n                }\n                // FIXME: oh no...\n                const newChannel = channel;\n                newChannel.state.members[event.user.id].user = event.user;\n                return newChannel;\n            });\n            return newChannels;\n        });\n    }, []);\n    return useMemo(() => ({\n        handleChannelDeleted,\n        handleChannelHidden,\n        handleChannelTruncated,\n        handleChannelUpdated,\n        handleChannelVisible,\n        handleMemberUpdated,\n        handleMessageNew,\n        handleNotificationAddedToChannel,\n        handleNotificationMessageNew,\n        handleNotificationRemovedFromChannel,\n        handleUserPresenceChanged,\n    }), [\n        handleChannelDeleted,\n        handleChannelHidden,\n        handleChannelTruncated,\n        handleChannelUpdated,\n        handleChannelVisible,\n        handleMemberUpdated,\n        handleMessageNew,\n        handleNotificationAddedToChannel,\n        handleNotificationMessageNew,\n        handleNotificationRemovedFromChannel,\n        handleUserPresenceChanged,\n    ]);\n};\nexport const usePrepareShapeHandlers = ({ allowNewMessagesFromUnfilteredChannels, customHandleChannelListShape, filters, lockChannelOrder, onAddedToChannel, onChannelDeleted, onChannelHidden, onChannelTruncated, onChannelUpdated, onChannelVisible, onMessageNew, onMessageNewHandler, onRemovedFromChannel, setChannels, sort, }) => {\n    const defaults = useChannelListShapeDefaults();\n    const defaultHandleChannelListShapeRef = useRef(undefined);\n    const customHandleChannelListShapeRef = useRef(undefined);\n    customHandleChannelListShapeRef.current = (event) => {\n        customHandleChannelListShape?.({ defaults, event, setChannels });\n    };\n    defaultHandleChannelListShapeRef.current = (event) => {\n        switch (event.type) {\n            case 'message.new':\n                defaults.handleMessageNew({\n                    allowNewMessagesFromUnfilteredChannels,\n                    customHandler: onMessageNewHandler,\n                    event,\n                    filters,\n                    lockChannelOrder,\n                    setChannels,\n                    sort,\n                });\n                break;\n            case 'notification.message_new':\n                defaults.handleNotificationMessageNew({\n                    allowNewMessagesFromUnfilteredChannels,\n                    customHandler: onMessageNew,\n                    event,\n                    filters,\n                    lockChannelOrder,\n                    setChannels,\n                    sort,\n                });\n                break;\n            case 'notification.added_to_channel':\n                defaults.handleNotificationAddedToChannel({\n                    allowNewMessagesFromUnfilteredChannels,\n                    customHandler: onAddedToChannel,\n                    event,\n                    lockChannelOrder,\n                    setChannels,\n                    sort,\n                });\n                break;\n            case 'notification.removed_from_channel':\n                defaults.handleNotificationRemovedFromChannel({\n                    customHandler: onRemovedFromChannel,\n                    event,\n                    setChannels,\n                });\n                break;\n            case 'channel.deleted':\n                defaults.handleChannelDeleted({\n                    customHandler: onChannelDeleted,\n                    event,\n                    setChannels,\n                });\n                break;\n            case 'channel.hidden':\n                defaults.handleChannelHidden({\n                    customHandler: onChannelHidden,\n                    event,\n                    setChannels,\n                });\n                break;\n            case 'channel.visible':\n                defaults.handleChannelVisible({\n                    customHandler: onChannelVisible,\n                    event,\n                    filters,\n                    setChannels,\n                    sort,\n                });\n                break;\n            case 'channel.truncated':\n                defaults.handleChannelTruncated({\n                    customHandler: onChannelTruncated,\n                    event,\n                    setChannels,\n                });\n                break;\n            case 'channel.updated':\n                defaults.handleChannelUpdated({\n                    customHandler: onChannelUpdated,\n                    event,\n                    setChannels,\n                });\n                break;\n            case 'user.presence.changed':\n                defaults.handleUserPresenceChanged({ event, setChannels });\n                break;\n            case 'member.updated':\n                defaults.handleMemberUpdated({\n                    event,\n                    filters,\n                    lockChannelOrder,\n                    setChannels,\n                    sort,\n                });\n                break;\n            default:\n                break;\n        }\n    };\n    const defaultFn = useCallback((e) => {\n        defaultHandleChannelListShapeRef.current?.(e);\n    }, []);\n    const customFn = useMemo(() => {\n        if (!customHandleChannelListShape)\n            return null;\n        return (e) => {\n            customHandleChannelListShapeRef.current?.(e);\n        };\n    }, [customHandleChannelListShape]);\n    return {\n        customHandler: customFn,\n        defaultHandler: defaultFn,\n    };\n};\nexport const useChannelListShape = (handler) => {\n    const { client } = useChatContext();\n    useEffect(() => {\n        const subscription = client.on('all', handler);\n        return subscription.unsubscribe;\n    }, [client, handler]);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}