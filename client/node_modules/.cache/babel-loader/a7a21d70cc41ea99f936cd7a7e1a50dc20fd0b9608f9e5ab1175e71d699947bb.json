{"ast":null,"code":"import { useCallback } from 'react';\nexport const useHandleFileChangeWrapper = (resetOnChange = false, handler) => useCallback(({\n  currentTarget\n}) => {\n  const {\n    files\n  } = currentTarget;\n  if (!files) return;\n  try {\n    handler?.(Array.from(files));\n  } catch (error) {\n    console.error(error);\n  }\n  if (resetOnChange) currentTarget.value = '';\n}, [handler, resetOnChange]);\nexport function dataTransferItemsHaveFiles(items) {\n  if (!items || !items.length) {\n    return false;\n  }\n  for (const item of items) {\n    if (item.kind === 'file' || item.type === 'text/html') {\n      return true;\n    }\n  }\n  return false;\n}\nexport async function dataTransferItemsToFiles(items) {\n  if (!items || !items.length) {\n    return [];\n  }\n  // If there are files inside the DataTransferItem prefer those\n  const fileLikes = getFileLikes(items);\n  if (fileLikes.length) {\n    return fileLikes;\n  }\n  // Otherwise extract images from html\n  const blobPromises = [];\n  for (const item of items) {\n    if (item.type === 'text/html') {\n      blobPromises.push(new Promise(accept => {\n        item.getAsString(async s => {\n          const imagePromises = extractImageSources(s).map(src => getImageSource(fileLikes, src));\n          await Promise.all(imagePromises);\n          accept();\n        });\n      }));\n    }\n  }\n  await Promise.all(blobPromises);\n  return fileLikes;\n}\nfunction getFileLikes(items) {\n  const fileLikes = [];\n  for (const item of items) {\n    if (item.kind === 'file') {\n      const file = item.getAsFile();\n      if (file) {\n        fileLikes.push(file);\n      }\n    }\n  }\n  return fileLikes;\n}\nasync function getImageSource(fileLikes, src) {\n  let res;\n  try {\n    res = await fetch(src);\n  } catch (e) {\n    return;\n  }\n  const contentType = res.headers.get('Content-type') || 'application/octet-stream';\n  const buf = await res.arrayBuffer();\n  const blob = new Blob([buf], {\n    type: contentType\n  });\n  fileLikes.push(blob);\n}\nconst extractImageSources = s => {\n  const imageTags = new DOMParser().parseFromString(s, 'text/html').getElementsByTagName('img');\n  return Array.from(imageTags, tag => tag.src).filter(tag => tag);\n};\nexport const isBlobButNotFile = obj => obj instanceof Blob && !(obj instanceof File);\nexport const createFileFromBlobs = ({\n  blobsArray,\n  fileName,\n  mimeType\n}) => {\n  const concatenatedBlob = new Blob(blobsArray, {\n    type: mimeType\n  });\n  return new File([concatenatedBlob], fileName, {\n    type: concatenatedBlob.type\n  });\n};\nexport const getExtensionFromMimeType = mimeType => {\n  const match = mimeType.match(/\\/([^/;]+)/);\n  return match && match[1];\n};\nexport const getRecordedMediaTypeFromMimeType = mimeType => {\n  const match = mimeType.match(/^(audio|video)\\/.*$/);\n  return match && match[1];\n};\nexport const readFileAsArrayBuffer = file => new Promise((resolve, reject) => {\n  const fileReader = new FileReader();\n  fileReader.onload = () => {\n    resolve(fileReader.result);\n  };\n  fileReader.onerror = () => {\n    reject(fileReader.error);\n  };\n  fileReader.readAsArrayBuffer(file);\n});\nexport const generateFileName = mimeType => `file_${new Date().toISOString()}.${getExtensionFromMimeType(mimeType)}`;","map":{"version":3,"names":["useCallback","useHandleFileChangeWrapper","resetOnChange","handler","currentTarget","files","Array","from","error","console","value","dataTransferItemsHaveFiles","items","length","item","kind","type","dataTransferItemsToFiles","fileLikes","getFileLikes","blobPromises","push","Promise","accept","getAsString","s","imagePromises","extractImageSources","map","src","getImageSource","all","file","getAsFile","res","fetch","e","contentType","headers","get","buf","arrayBuffer","blob","Blob","imageTags","DOMParser","parseFromString","getElementsByTagName","tag","filter","isBlobButNotFile","obj","File","createFileFromBlobs","blobsArray","fileName","mimeType","concatenatedBlob","getExtensionFromMimeType","match","getRecordedMediaTypeFromMimeType","readFileAsArrayBuffer","resolve","reject","fileReader","FileReader","onload","result","onerror","readAsArrayBuffer","generateFileName","Date","toISOString"],"sources":["/Users/yashwantmoharil/Desktop/football-battlegrounds/client/node_modules/stream-chat-react/dist/components/ReactFileUtilities/utils.js"],"sourcesContent":["import { useCallback } from 'react';\nexport const useHandleFileChangeWrapper = (resetOnChange = false, handler) => useCallback(({ currentTarget }) => {\n    const { files } = currentTarget;\n    if (!files)\n        return;\n    try {\n        handler?.(Array.from(files));\n    }\n    catch (error) {\n        console.error(error);\n    }\n    if (resetOnChange)\n        currentTarget.value = '';\n}, [handler, resetOnChange]);\nexport function dataTransferItemsHaveFiles(items) {\n    if (!items || !items.length) {\n        return false;\n    }\n    for (const item of items) {\n        if (item.kind === 'file' || item.type === 'text/html') {\n            return true;\n        }\n    }\n    return false;\n}\nexport async function dataTransferItemsToFiles(items) {\n    if (!items || !items.length) {\n        return [];\n    }\n    // If there are files inside the DataTransferItem prefer those\n    const fileLikes = getFileLikes(items);\n    if (fileLikes.length) {\n        return fileLikes;\n    }\n    // Otherwise extract images from html\n    const blobPromises = [];\n    for (const item of items) {\n        if (item.type === 'text/html') {\n            blobPromises.push(new Promise((accept) => {\n                item.getAsString(async (s) => {\n                    const imagePromises = extractImageSources(s).map((src) => getImageSource(fileLikes, src));\n                    await Promise.all(imagePromises);\n                    accept();\n                });\n            }));\n        }\n    }\n    await Promise.all(blobPromises);\n    return fileLikes;\n}\nfunction getFileLikes(items) {\n    const fileLikes = [];\n    for (const item of items) {\n        if (item.kind === 'file') {\n            const file = item.getAsFile();\n            if (file) {\n                fileLikes.push(file);\n            }\n        }\n    }\n    return fileLikes;\n}\nasync function getImageSource(fileLikes, src) {\n    let res;\n    try {\n        res = await fetch(src);\n    }\n    catch (e) {\n        return;\n    }\n    const contentType = res.headers.get('Content-type') || 'application/octet-stream';\n    const buf = await res.arrayBuffer();\n    const blob = new Blob([buf], { type: contentType });\n    fileLikes.push(blob);\n}\nconst extractImageSources = (s) => {\n    const imageTags = new DOMParser()\n        .parseFromString(s, 'text/html')\n        .getElementsByTagName('img');\n    return Array.from(imageTags, (tag) => tag.src).filter((tag) => tag);\n};\nexport const isBlobButNotFile = (obj) => obj instanceof Blob && !(obj instanceof File);\nexport const createFileFromBlobs = ({ blobsArray, fileName, mimeType, }) => {\n    const concatenatedBlob = new Blob(blobsArray, { type: mimeType });\n    return new File([concatenatedBlob], fileName, { type: concatenatedBlob.type });\n};\nexport const getExtensionFromMimeType = (mimeType) => {\n    const match = mimeType.match(/\\/([^/;]+)/);\n    return match && match[1];\n};\nexport const getRecordedMediaTypeFromMimeType = (mimeType) => {\n    const match = mimeType.match(/^(audio|video)\\/.*$/);\n    return match && match[1];\n};\nexport const readFileAsArrayBuffer = (file) => new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n        resolve(fileReader.result);\n    };\n    fileReader.onerror = () => {\n        reject(fileReader.error);\n    };\n    fileReader.readAsArrayBuffer(file);\n});\nexport const generateFileName = (mimeType) => `file_${new Date().toISOString()}.${getExtensionFromMimeType(mimeType)}`;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}