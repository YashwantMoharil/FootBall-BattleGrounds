{"ast":null,"code":"import React, { useCallback, useEffect, useLayoutEffect, useMemo, useReducer, useRef, useState } from 'react';\nimport clsx from 'clsx';\nimport debounce from 'lodash.debounce';\nimport defaultsDeep from 'lodash.defaultsdeep';\nimport throttle from 'lodash.throttle';\nimport { localMessageToNewMessagePayload } from 'stream-chat';\nimport { initialState, makeChannelReducer } from './channelState';\nimport { useCreateChannelStateContext } from './hooks/useCreateChannelStateContext';\nimport { useCreateTypingContext } from './hooks/useCreateTypingContext';\nimport { useEditMessageHandler } from './hooks/useEditMessageHandler';\nimport { useIsMounted } from './hooks/useIsMounted';\nimport { useMentionsHandlers } from './hooks/useMentionsHandlers';\nimport { LoadingErrorIndicator as DefaultLoadingErrorIndicator } from '../Loading';\nimport { LoadingChannel as DefaultLoadingIndicator } from './LoadingChannel';\nimport { ChannelActionProvider, ChannelStateProvider, TypingProvider, useChatContext, useTranslationContext, WithComponents } from '../../context';\nimport { CHANNEL_CONTAINER_ID } from './constants';\nimport { DEFAULT_HIGHLIGHT_DURATION, DEFAULT_INITIAL_CHANNEL_PAGE_SIZE, DEFAULT_JUMP_TO_PAGE_SIZE, DEFAULT_NEXT_CHANNEL_PAGE_SIZE, DEFAULT_THREAD_PAGE_SIZE } from '../../constants/limits';\nimport { hasMoreMessagesProbably } from '../MessageList';\nimport { getChatContainerClass, useChannelContainerClasses, useImageFlagEmojisOnWindowsClass } from './hooks/useChannelContainerClasses';\nimport { findInMsgSetByDate, findInMsgSetById, makeAddNotifications } from './utils';\nimport { useThreadContext } from '../Threads';\nimport { getChannel } from '../../utils';\nimport { getImageAttachmentConfiguration, getVideoAttachmentConfiguration } from '../Attachment/attachment-sizing';\nimport { useSearchFocusedMessage } from '../../experimental/Search/hooks';\nconst ChannelContainer = ({\n  children,\n  className: additionalClassName,\n  ...props\n}) => {\n  const {\n    customClasses,\n    theme\n  } = useChatContext('Channel');\n  const {\n    channelClass,\n    chatClass\n  } = useChannelContainerClasses({\n    customClasses\n  });\n  const className = clsx(chatClass, theme, channelClass, additionalClassName);\n  return React.createElement(\"div\", {\n    id: CHANNEL_CONTAINER_ID,\n    ...props,\n    className: className\n  }, children);\n};\nconst UnMemoizedChannel = props => {\n  const {\n    channel: propsChannel,\n    EmptyPlaceholder = null,\n    LoadingErrorIndicator,\n    LoadingIndicator = DefaultLoadingIndicator\n  } = props;\n  const {\n    channel: contextChannel,\n    channelsQueryState\n  } = useChatContext('Channel');\n  const channel = propsChannel || contextChannel;\n  if (channelsQueryState.queryInProgress === 'reload' && LoadingIndicator) {\n    return React.createElement(ChannelContainer, null, React.createElement(LoadingIndicator, null));\n  }\n  if (channelsQueryState.error && LoadingErrorIndicator) {\n    return React.createElement(ChannelContainer, null, React.createElement(LoadingErrorIndicator, {\n      error: channelsQueryState.error\n    }));\n  }\n  if (!channel?.cid) {\n    return React.createElement(ChannelContainer, null, EmptyPlaceholder);\n  }\n  return React.createElement(ChannelInner, {\n    ...props,\n    channel: channel,\n    key: channel.cid\n  });\n};\nconst ChannelInner = props => {\n  const {\n    activeUnreadHandler,\n    channel,\n    channelQueryOptions: propChannelQueryOptions,\n    children,\n    doDeleteMessageRequest,\n    doMarkReadRequest,\n    doSendMessageRequest,\n    doUpdateMessageRequest,\n    initializeOnMount = true,\n    LoadingErrorIndicator = DefaultLoadingErrorIndicator,\n    LoadingIndicator = DefaultLoadingIndicator,\n    markReadOnMount = true,\n    onMentionsClick,\n    onMentionsHover,\n    skipMessageDataMemoization\n  } = props;\n  const channelQueryOptions = useMemo(() => defaultsDeep(propChannelQueryOptions, {\n    messages: {\n      limit: DEFAULT_INITIAL_CHANNEL_PAGE_SIZE\n    }\n  }), [propChannelQueryOptions]);\n  const {\n    client,\n    customClasses,\n    latestMessageDatesByChannels,\n    mutes,\n    searchController\n  } = useChatContext('Channel');\n  const {\n    t\n  } = useTranslationContext('Channel');\n  const chatContainerClass = getChatContainerClass(customClasses?.chatContainer);\n  const windowsEmojiClass = useImageFlagEmojisOnWindowsClass();\n  const thread = useThreadContext();\n  const [channelConfig, setChannelConfig] = useState(channel.getConfig());\n  const [notifications, setNotifications] = useState([]);\n  const notificationTimeouts = useRef([]);\n  const [channelUnreadUiState, _setChannelUnreadUiState] = useState();\n  const channelReducer = useMemo(() => makeChannelReducer(), []);\n  const [state, dispatch] = useReducer(channelReducer,\n  // channel.initialized === false if client.channel().query() was not called, e.g. ChannelList is not used\n  // => Channel will call channel.watch() in useLayoutEffect => state.loading is used to signal the watch() call state\n  {\n    ...initialState,\n    hasMore: channel.state.messagePagination.hasPrev,\n    loading: !channel.initialized,\n    messages: channel.state.messages\n  });\n  const jumpToMessageFromSearch = useSearchFocusedMessage();\n  const isMounted = useIsMounted();\n  const originalTitle = useRef('');\n  const lastRead = useRef(undefined);\n  const online = useRef(true);\n  const clearHighlightedMessageTimeoutId = useRef(null);\n  const channelCapabilitiesArray = channel.data?.own_capabilities;\n  const throttledCopyStateFromChannel = throttle(() => dispatch({\n    channel,\n    type: 'copyStateFromChannelOnEvent'\n  }), 500, {\n    leading: true,\n    trailing: true\n  });\n  const setChannelUnreadUiState = useMemo(() => throttle(_setChannelUnreadUiState, 200, {\n    leading: true,\n    trailing: false\n  }), []);\n  const markRead = useMemo(() => throttle(async options => {\n    const {\n      updateChannelUiUnreadState = true\n    } = options ?? {};\n    if (channel.disconnected || !channelConfig?.read_events) {\n      return;\n    }\n    lastRead.current = new Date();\n    try {\n      if (doMarkReadRequest) {\n        doMarkReadRequest(channel, updateChannelUiUnreadState ? setChannelUnreadUiState : undefined);\n      } else {\n        const markReadResponse = await channel.markRead();\n        if (updateChannelUiUnreadState && markReadResponse) {\n          _setChannelUnreadUiState({\n            last_read: lastRead.current,\n            last_read_message_id: markReadResponse.event.last_read_message_id,\n            unread_messages: 0\n          });\n        }\n      }\n      if (activeUnreadHandler) {\n        activeUnreadHandler(0, originalTitle.current);\n      } else if (originalTitle.current) {\n        document.title = originalTitle.current;\n      }\n    } catch (e) {\n      console.error(t('Failed to mark channel as read'));\n    }\n  }, 500, {\n    leading: true,\n    trailing: false\n  }), [activeUnreadHandler, channel, channelConfig, doMarkReadRequest, setChannelUnreadUiState, t]);\n  const handleEvent = async event => {\n    if (event.message) {\n      dispatch({\n        channel,\n        message: event.message,\n        type: 'updateThreadOnEvent'\n      });\n    }\n    if (event.type === 'user.watching.start' || event.type === 'user.watching.stop') return;\n    if (event.type === 'typing.start' || event.type === 'typing.stop') {\n      return dispatch({\n        channel,\n        type: 'setTyping'\n      });\n    }\n    if (event.type === 'connection.changed' && typeof event.online === 'boolean') {\n      online.current = event.online;\n    }\n    if (event.type === 'message.new') {\n      const mainChannelUpdated = !event.message?.parent_id || event.message?.show_in_channel;\n      if (mainChannelUpdated) {\n        if (document.hidden && channelConfig?.read_events && !channel.muteStatus().muted) {\n          const unread = channel.countUnread(lastRead.current);\n          if (activeUnreadHandler) {\n            activeUnreadHandler(unread, originalTitle.current);\n          } else {\n            document.title = `(${unread}) ${originalTitle.current}`;\n          }\n        }\n      }\n      if (event.message?.user?.id === client.userID && event?.message?.created_at && event?.message?.cid) {\n        const messageDate = new Date(event.message.created_at);\n        const cid = event.message.cid;\n        if (!latestMessageDatesByChannels[cid] || latestMessageDatesByChannels[cid].getTime() < messageDate.getTime()) {\n          latestMessageDatesByChannels[cid] = messageDate;\n        }\n      }\n    }\n    if (event.type === 'user.deleted') {\n      const oldestID = channel.state?.messages?.[0]?.id;\n      /**\n       * As the channel state is not normalized we re-fetch the channel data. Thus, we avoid having to search for user references in the channel state.\n       */\n      // FIXME: we should use channelQueryOptions if they are available\n      await channel.query({\n        messages: {\n          id_lt: oldestID,\n          limit: DEFAULT_NEXT_CHANNEL_PAGE_SIZE\n        },\n        watchers: {\n          limit: DEFAULT_NEXT_CHANNEL_PAGE_SIZE\n        }\n      });\n    }\n    if (event.type === 'notification.mark_unread') _setChannelUnreadUiState(prev => {\n      if (!(event.last_read_at && event.user)) return prev;\n      return {\n        first_unread_message_id: event.first_unread_message_id,\n        last_read: new Date(event.last_read_at),\n        last_read_message_id: event.last_read_message_id,\n        unread_messages: event.unread_messages ?? 0\n      };\n    });\n    if (event.type === 'channel.truncated' && event.cid === channel.cid) {\n      _setChannelUnreadUiState(undefined);\n    }\n    throttledCopyStateFromChannel();\n  };\n  // useLayoutEffect here to prevent spinner. Use Suspense when it is available in stable release\n  useLayoutEffect(() => {\n    let errored = false;\n    let done = false;\n    (async () => {\n      if (!channel.initialized && initializeOnMount) {\n        try {\n          // if active channel has been set without id, we will create a temporary channel id from its member IDs\n          // to keep track of the /query request in progress. This is the same approach of generating temporary id\n          // that the JS client uses to keep track of channel in client.activeChannels\n          const members = [];\n          if (!channel.id && channel.data?.members) {\n            for (const member of channel.data.members) {\n              let userId;\n              if (typeof member === 'string') {\n                userId = member;\n              } else if (typeof member === 'object') {\n                const {\n                  user,\n                  user_id\n                } = member;\n                userId = user_id || user?.id;\n              }\n              if (userId) {\n                members.push(userId);\n              }\n            }\n          }\n          await getChannel({\n            channel,\n            client,\n            members,\n            options: channelQueryOptions\n          });\n          const config = channel.getConfig();\n          setChannelConfig(config);\n        } catch (e) {\n          dispatch({\n            error: e,\n            type: 'setError'\n          });\n          errored = true;\n        }\n      }\n      done = true;\n      originalTitle.current = document.title;\n      if (!errored) {\n        dispatch({\n          channel,\n          hasMore: channel.state.messagePagination.hasPrev,\n          type: 'initStateFromChannel'\n        });\n        if (client.user?.id && channel.state.read[client.user.id]) {\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const {\n            user,\n            ...ownReadState\n          } = channel.state.read[client.user.id];\n          _setChannelUnreadUiState(ownReadState);\n        }\n        /**\n         * TODO: maybe pass last_read to the countUnread method to get proper value\n         * combined with channel.countUnread adjustment (_countMessageAsUnread)\n         * to allow counting own messages too\n         *\n         * const lastRead = channel.state.read[client.userID as string].last_read;\n         */\n        if (channel.countUnread() > 0 && markReadOnMount) markRead({\n          updateChannelUiUnreadState: false\n        });\n        // The more complex sync logic is done in Chat\n        client.on('connection.changed', handleEvent);\n        client.on('connection.recovered', handleEvent);\n        client.on('user.updated', handleEvent);\n        client.on('user.deleted', handleEvent);\n        channel.on(handleEvent);\n      }\n    })();\n    const notificationTimeoutsRef = notificationTimeouts.current;\n    return () => {\n      if (errored || !done) return;\n      channel?.off(handleEvent);\n      client.off('connection.changed', handleEvent);\n      client.off('connection.recovered', handleEvent);\n      client.off('user.deleted', handleEvent);\n      notificationTimeoutsRef.forEach(clearTimeout);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [channel.cid, channelQueryOptions, doMarkReadRequest, channelConfig?.read_events, initializeOnMount]);\n  useEffect(() => {\n    if (!state.thread) return;\n    const message = state.messages?.find(m => m.id === state.thread?.id);\n    if (message) dispatch({\n      message,\n      type: 'setThread'\n    });\n  }, [state.messages, state.thread]);\n  const handleHighlightedMessageChange = useCallback(({\n    highlightDuration,\n    highlightedMessageId\n  }) => {\n    dispatch({\n      channel,\n      highlightedMessageId,\n      type: 'jumpToMessageFinished'\n    });\n    if (clearHighlightedMessageTimeoutId.current) {\n      clearTimeout(clearHighlightedMessageTimeoutId.current);\n    }\n    clearHighlightedMessageTimeoutId.current = setTimeout(() => {\n      if (searchController._internalState.getLatestValue().focusedMessage) {\n        searchController._internalState.partialNext({\n          focusedMessage: undefined\n        });\n      }\n      clearHighlightedMessageTimeoutId.current = null;\n      dispatch({\n        type: 'clearHighlightedMessage'\n      });\n    }, highlightDuration ?? DEFAULT_HIGHLIGHT_DURATION);\n  }, [channel, searchController]);\n  useEffect(() => {\n    if (!jumpToMessageFromSearch?.id) return;\n    handleHighlightedMessageChange({\n      highlightedMessageId: jumpToMessageFromSearch.id\n    });\n  }, [jumpToMessageFromSearch, handleHighlightedMessageChange]);\n  /** MESSAGE */\n  // Adds a temporary notification to message list, will be removed after 5 seconds\n  const addNotification = useMemo(() => makeAddNotifications(setNotifications, notificationTimeouts.current), []);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const loadMoreFinished = useCallback(debounce((hasMore, messages) => {\n    if (!isMounted.current) return;\n    dispatch({\n      hasMore,\n      messages,\n      type: 'loadMoreFinished'\n    });\n  }, 2000, {\n    leading: true,\n    trailing: true\n  }), []);\n  const loadMore = async (limit = DEFAULT_NEXT_CHANNEL_PAGE_SIZE) => {\n    if (!online.current || !window.navigator.onLine || !channel.state.messagePagination.hasPrev) return 0;\n    // prevent duplicate loading events...\n    const oldestMessage = state?.messages?.[0];\n    if (state.loadingMore || state.loadingMoreNewer || oldestMessage?.status !== 'received') {\n      return 0;\n    }\n    dispatch({\n      loadingMore: true,\n      type: 'setLoadingMore'\n    });\n    const oldestID = oldestMessage?.id;\n    const perPage = limit;\n    let queryResponse;\n    try {\n      queryResponse = await channel.query({\n        messages: {\n          id_lt: oldestID,\n          limit: perPage\n        },\n        watchers: {\n          limit: perPage\n        }\n      });\n    } catch (e) {\n      console.warn('message pagination request failed with error', e);\n      dispatch({\n        loadingMore: false,\n        type: 'setLoadingMore'\n      });\n      return 0;\n    }\n    loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n    return queryResponse.messages.length;\n  };\n  const loadMoreNewer = async (limit = DEFAULT_NEXT_CHANNEL_PAGE_SIZE) => {\n    if (!online.current || !window.navigator.onLine || !channel.state.messagePagination.hasNext) return 0;\n    const newestMessage = state?.messages?.[state?.messages?.length - 1];\n    if (state.loadingMore || state.loadingMoreNewer) return 0;\n    dispatch({\n      loadingMoreNewer: true,\n      type: 'setLoadingMoreNewer'\n    });\n    const newestId = newestMessage?.id;\n    const perPage = limit;\n    let queryResponse;\n    try {\n      queryResponse = await channel.query({\n        messages: {\n          id_gt: newestId,\n          limit: perPage\n        },\n        watchers: {\n          limit: perPage\n        }\n      });\n    } catch (e) {\n      console.warn('message pagination request failed with error', e);\n      dispatch({\n        loadingMoreNewer: false,\n        type: 'setLoadingMoreNewer'\n      });\n      return 0;\n    }\n    dispatch({\n      hasMoreNewer: channel.state.messagePagination.hasNext,\n      messages: channel.state.messages,\n      type: 'loadMoreNewerFinished'\n    });\n    return queryResponse.messages.length;\n  };\n  const jumpToMessage = useCallback(async (messageId, messageLimit = DEFAULT_JUMP_TO_PAGE_SIZE, highlightDuration = DEFAULT_HIGHLIGHT_DURATION) => {\n    dispatch({\n      loadingMore: true,\n      type: 'setLoadingMore'\n    });\n    await channel.state.loadMessageIntoState(messageId, undefined, messageLimit);\n    loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n    handleHighlightedMessageChange({\n      highlightDuration,\n      highlightedMessageId: messageId\n    });\n  }, [channel, handleHighlightedMessageChange, loadMoreFinished]);\n  const jumpToLatestMessage = useCallback(async () => {\n    await channel.state.loadMessageIntoState('latest');\n    loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n    dispatch({\n      type: 'jumpToLatestMessage'\n    });\n  }, [channel, loadMoreFinished]);\n  const jumpToFirstUnreadMessage = useCallback(async (queryMessageLimit = DEFAULT_JUMP_TO_PAGE_SIZE, highlightDuration = DEFAULT_HIGHLIGHT_DURATION) => {\n    if (!channelUnreadUiState?.unread_messages) return;\n    let lastReadMessageId = channelUnreadUiState?.last_read_message_id;\n    let firstUnreadMessageId = channelUnreadUiState?.first_unread_message_id;\n    let isInCurrentMessageSet = false;\n    if (firstUnreadMessageId) {\n      const result = findInMsgSetById(firstUnreadMessageId, channel.state.messages);\n      isInCurrentMessageSet = result.index !== -1;\n    } else if (lastReadMessageId) {\n      const result = findInMsgSetById(lastReadMessageId, channel.state.messages);\n      isInCurrentMessageSet = !!result.target;\n      firstUnreadMessageId = result.index > -1 ? channel.state.messages[result.index + 1]?.id : undefined;\n    } else {\n      const lastReadTimestamp = channelUnreadUiState.last_read.getTime();\n      const {\n        index: lastReadMessageIndex,\n        target: lastReadMessage\n      } = findInMsgSetByDate(channelUnreadUiState.last_read, channel.state.messages, true);\n      if (lastReadMessage) {\n        firstUnreadMessageId = channel.state.messages[lastReadMessageIndex + 1]?.id;\n        isInCurrentMessageSet = !!firstUnreadMessageId;\n        lastReadMessageId = lastReadMessage.id;\n      } else {\n        dispatch({\n          loadingMore: true,\n          type: 'setLoadingMore'\n        });\n        let messages;\n        try {\n          messages = (await channel.query({\n            messages: {\n              created_at_around: channelUnreadUiState.last_read.toISOString(),\n              limit: queryMessageLimit\n            }\n          }, 'new')).messages;\n        } catch (e) {\n          addNotification(t('Failed to jump to the first unread message'), 'error');\n          loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n          return;\n        }\n        const firstMessageWithCreationDate = messages.find(msg => msg.created_at);\n        if (!firstMessageWithCreationDate) {\n          addNotification(t('Failed to jump to the first unread message'), 'error');\n          loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n          return;\n        }\n        const firstMessageTimestamp = new Date(firstMessageWithCreationDate.created_at).getTime();\n        if (lastReadTimestamp < firstMessageTimestamp) {\n          // whole channel is unread\n          firstUnreadMessageId = firstMessageWithCreationDate.id;\n        } else {\n          const result = findInMsgSetByDate(channelUnreadUiState.last_read, messages);\n          lastReadMessageId = result.target?.id;\n        }\n        loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n      }\n    }\n    if (!firstUnreadMessageId && !lastReadMessageId) {\n      addNotification(t('Failed to jump to the first unread message'), 'error');\n      return;\n    }\n    if (!isInCurrentMessageSet) {\n      dispatch({\n        loadingMore: true,\n        type: 'setLoadingMore'\n      });\n      try {\n        const targetId = firstUnreadMessageId ?? lastReadMessageId;\n        await channel.state.loadMessageIntoState(targetId, undefined, queryMessageLimit);\n        /**\n         * if the index of the last read message on the page is beyond the half of the page,\n         * we have arrived to the oldest page of the channel\n         */\n        const indexOfTarget = channel.state.messages.findIndex(message => message.id === targetId);\n        loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n        firstUnreadMessageId = firstUnreadMessageId ?? channel.state.messages[indexOfTarget + 1]?.id;\n      } catch (e) {\n        addNotification(t('Failed to jump to the first unread message'), 'error');\n        loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n        return;\n      }\n    }\n    if (!firstUnreadMessageId) {\n      addNotification(t('Failed to jump to the first unread message'), 'error');\n      return;\n    }\n    if (!channelUnreadUiState.first_unread_message_id) _setChannelUnreadUiState({\n      ...channelUnreadUiState,\n      first_unread_message_id: firstUnreadMessageId,\n      last_read_message_id: lastReadMessageId\n    });\n    handleHighlightedMessageChange({\n      highlightDuration,\n      highlightedMessageId: firstUnreadMessageId\n    });\n  }, [addNotification, channel, handleHighlightedMessageChange, loadMoreFinished, t, channelUnreadUiState]);\n  const deleteMessage = useCallback(async message => {\n    if (!message?.id) {\n      throw new Error('Cannot delete a message - missing message ID.');\n    }\n    let deletedMessage;\n    if (doDeleteMessageRequest) {\n      deletedMessage = await doDeleteMessageRequest(message);\n    } else {\n      const result = await client.deleteMessage(message.id);\n      deletedMessage = result.message;\n    }\n    return deletedMessage;\n  }, [client, doDeleteMessageRequest]);\n  const updateMessage = updatedMessage => {\n    // add the message to the local channel state\n    channel.state.addMessageSorted(updatedMessage, true);\n    dispatch({\n      channel,\n      parentId: state.thread && updatedMessage.parent_id,\n      type: 'copyMessagesFromChannel'\n    });\n  };\n  const doSendMessage = async ({\n    localMessage,\n    message,\n    options\n  }) => {\n    try {\n      let messageResponse;\n      if (doSendMessageRequest) {\n        messageResponse = await doSendMessageRequest(channel, message, options);\n      } else {\n        messageResponse = await channel.sendMessage(message, options);\n      }\n      let existingMessage = undefined;\n      for (let i = channel.state.messages.length - 1; i >= 0; i--) {\n        const msg = channel.state.messages[i];\n        if (msg.id && msg.id === message.id) {\n          existingMessage = msg;\n          break;\n        }\n      }\n      const responseTimestamp = new Date(messageResponse?.message?.updated_at || 0).getTime();\n      const existingMessageTimestamp = existingMessage?.updated_at?.getTime() || 0;\n      const responseIsTheNewest = responseTimestamp > existingMessageTimestamp;\n      // Replace the message payload after send is completed\n      // We need to check for the newest message payload, because on slow network, the response can arrive later than WS events message.new, message.updated.\n      // Always override existing message in status \"sending\"\n      if (messageResponse?.message && (responseIsTheNewest || existingMessage?.status === 'sending')) {\n        updateMessage({\n          ...messageResponse.message,\n          status: 'received'\n        });\n      }\n    } catch (error) {\n      // error response isn't usable so needs to be stringified then parsed\n      const stringError = JSON.stringify(error);\n      const parsedError = stringError ? JSON.parse(stringError) : {};\n      // Handle the case where the message already exists\n      // (typically, when retrying to send a message).\n      // If the message already exists, we can assume it was sent successfully,\n      // so we update the message status to \"received\".\n      // Right now, the only way to check this error is by checking\n      // the combination of the error code and the error description,\n      // since there is no special error code for duplicate messages.\n      if (parsedError.code === 4 && error instanceof Error && error.message.includes('already exists')) {\n        updateMessage({\n          ...localMessage,\n          status: 'received'\n        });\n      } else {\n        updateMessage({\n          ...localMessage,\n          error: parsedError,\n          status: 'failed'\n        });\n        thread?.upsertReplyLocally({\n          message: {\n            ...localMessage,\n            error: parsedError,\n            status: 'failed'\n          }\n        });\n      }\n    }\n  };\n  const sendMessage = async ({\n    localMessage,\n    message,\n    options\n  }) => {\n    channel.state.filterErrorMessages();\n    thread?.upsertReplyLocally({\n      message: localMessage\n    });\n    updateMessage(localMessage);\n    await doSendMessage({\n      localMessage,\n      message,\n      options\n    });\n  };\n  const retrySendMessage = async localMessage => {\n    updateMessage({\n      ...localMessage,\n      error: undefined,\n      status: 'sending'\n    });\n    await doSendMessage({\n      localMessage,\n      message: localMessageToNewMessagePayload(localMessage)\n    });\n  };\n  const removeMessage = message => {\n    channel.state.removeMessage(message);\n    dispatch({\n      channel,\n      parentId: state.thread && message.parent_id,\n      type: 'copyMessagesFromChannel'\n    });\n  };\n  /** THREAD */\n  const openThread = (message, event) => {\n    event?.preventDefault();\n    dispatch({\n      channel,\n      message,\n      type: 'openThread'\n    });\n  };\n  const closeThread = event => {\n    event?.preventDefault();\n    dispatch({\n      type: 'closeThread'\n    });\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const loadMoreThreadFinished = useCallback(debounce((threadHasMore, threadMessages) => {\n    dispatch({\n      threadHasMore,\n      threadMessages,\n      type: 'loadMoreThreadFinished'\n    });\n  }, 2000, {\n    leading: true,\n    trailing: true\n  }), []);\n  const loadMoreThread = async (limit = DEFAULT_THREAD_PAGE_SIZE) => {\n    // FIXME: should prevent loading more, if state.thread.reply_count === channel.state.threads[parentID].length\n    if (state.threadLoadingMore || !state.thread || !state.threadHasMore) return;\n    dispatch({\n      type: 'startLoadingThread'\n    });\n    const parentId = state.thread.id;\n    if (!parentId) {\n      return dispatch({\n        type: 'closeThread'\n      });\n    }\n    const oldMessages = channel.state.threads[parentId] || [];\n    const oldestMessageId = oldMessages[0]?.id;\n    try {\n      const queryResponse = await channel.getReplies(parentId, {\n        id_lt: oldestMessageId,\n        limit\n      });\n      const threadHasMoreMessages = hasMoreMessagesProbably(queryResponse.messages.length, limit);\n      const newThreadMessages = channel.state.threads[parentId] || [];\n      // next set loadingMore to false so we can start asking for more data\n      loadMoreThreadFinished(threadHasMoreMessages, newThreadMessages);\n    } catch (e) {\n      loadMoreThreadFinished(false, oldMessages);\n    }\n  };\n  const onMentionsHoverOrClick = useMentionsHandlers(onMentionsHover, onMentionsClick);\n  const editMessage = useEditMessageHandler(doUpdateMessageRequest);\n  const {\n    typing,\n    ...restState\n  } = state;\n  const channelStateContextValue = useCreateChannelStateContext({\n    ...restState,\n    channel,\n    channelCapabilitiesArray,\n    channelConfig,\n    channelUnreadUiState,\n    giphyVersion: props.giphyVersion || 'fixed_height',\n    imageAttachmentSizeHandler: props.imageAttachmentSizeHandler || getImageAttachmentConfiguration,\n    mutes,\n    notifications,\n    shouldGenerateVideoThumbnail: props.shouldGenerateVideoThumbnail || true,\n    videoAttachmentSizeHandler: props.videoAttachmentSizeHandler || getVideoAttachmentConfiguration,\n    watcher_count: state.watcherCount\n  });\n  const channelActionContextValue = useMemo(() => ({\n    addNotification,\n    closeThread,\n    deleteMessage,\n    dispatch,\n    editMessage,\n    jumpToFirstUnreadMessage,\n    jumpToLatestMessage,\n    jumpToMessage,\n    loadMore,\n    loadMoreNewer,\n    loadMoreThread,\n    markRead,\n    onMentionsClick: onMentionsHoverOrClick,\n    onMentionsHover: onMentionsHoverOrClick,\n    openThread,\n    removeMessage,\n    retrySendMessage,\n    sendMessage,\n    setChannelUnreadUiState,\n    skipMessageDataMemoization,\n    updateMessage\n  }),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [channel.cid, deleteMessage, loadMore, loadMoreNewer, markRead, jumpToFirstUnreadMessage, jumpToMessage, jumpToLatestMessage, setChannelUnreadUiState]);\n  const componentContextValue = useMemo(() => ({\n    Attachment: props.Attachment,\n    AttachmentPreviewList: props.AttachmentPreviewList,\n    AttachmentSelector: props.AttachmentSelector,\n    AttachmentSelectorInitiationButtonContents: props.AttachmentSelectorInitiationButtonContents,\n    AudioRecorder: props.AudioRecorder,\n    AutocompleteSuggestionItem: props.AutocompleteSuggestionItem,\n    AutocompleteSuggestionList: props.AutocompleteSuggestionList,\n    Avatar: props.Avatar,\n    BaseImage: props.BaseImage,\n    CooldownTimer: props.CooldownTimer,\n    CustomMessageActionsList: props.CustomMessageActionsList,\n    DateSeparator: props.DateSeparator,\n    EditMessageInput: props.EditMessageInput,\n    EmojiPicker: props.EmojiPicker,\n    emojiSearchIndex: props.emojiSearchIndex,\n    EmptyStateIndicator: props.EmptyStateIndicator,\n    FileUploadIcon: props.FileUploadIcon,\n    GiphyPreviewMessage: props.GiphyPreviewMessage,\n    HeaderComponent: props.HeaderComponent,\n    Input: props.Input,\n    LinkPreviewList: props.LinkPreviewList,\n    LoadingIndicator: props.LoadingIndicator,\n    Message: props.Message,\n    MessageActions: props.MessageActions,\n    MessageBlocked: props.MessageBlocked,\n    MessageBouncePrompt: props.MessageBouncePrompt,\n    MessageDeleted: props.MessageDeleted,\n    MessageIsThreadReplyInChannelButtonIndicator: props.MessageIsThreadReplyInChannelButtonIndicator,\n    MessageListNotifications: props.MessageListNotifications,\n    MessageNotification: props.MessageNotification,\n    MessageOptions: props.MessageOptions,\n    MessageRepliesCountButton: props.MessageRepliesCountButton,\n    MessageStatus: props.MessageStatus,\n    MessageSystem: props.MessageSystem,\n    MessageTimestamp: props.MessageTimestamp,\n    ModalGallery: props.ModalGallery,\n    PinIndicator: props.PinIndicator,\n    PollActions: props.PollActions,\n    PollContent: props.PollContent,\n    PollCreationDialog: props.PollCreationDialog,\n    PollHeader: props.PollHeader,\n    PollOptionSelector: props.PollOptionSelector,\n    QuotedMessage: props.QuotedMessage,\n    QuotedMessagePreview: props.QuotedMessagePreview,\n    QuotedPoll: props.QuotedPoll,\n    reactionOptions: props.reactionOptions,\n    ReactionSelector: props.ReactionSelector,\n    ReactionsList: props.ReactionsList,\n    ReactionsListModal: props.ReactionsListModal,\n    ReminderNotification: props.ReminderNotification,\n    SendButton: props.SendButton,\n    SendToChannelCheckbox: props.SendToChannelCheckbox,\n    StartRecordingAudioButton: props.StartRecordingAudioButton,\n    StopAIGenerationButton: props.StopAIGenerationButton,\n    StreamedMessageText: props.StreamedMessageText,\n    TextareaComposer: props.TextareaComposer,\n    ThreadHead: props.ThreadHead,\n    ThreadHeader: props.ThreadHeader,\n    ThreadStart: props.ThreadStart,\n    Timestamp: props.Timestamp,\n    TypingIndicator: props.TypingIndicator,\n    UnreadMessagesNotification: props.UnreadMessagesNotification,\n    UnreadMessagesSeparator: props.UnreadMessagesSeparator,\n    VirtualMessage: props.VirtualMessage\n  }), [props.Attachment, props.AttachmentPreviewList, props.AttachmentSelector, props.AttachmentSelectorInitiationButtonContents, props.AudioRecorder, props.AutocompleteSuggestionItem, props.AutocompleteSuggestionList, props.Avatar, props.BaseImage, props.CooldownTimer, props.CustomMessageActionsList, props.DateSeparator, props.EditMessageInput, props.EmojiPicker, props.emojiSearchIndex, props.EmptyStateIndicator, props.FileUploadIcon, props.GiphyPreviewMessage, props.HeaderComponent, props.Input, props.LinkPreviewList, props.LoadingIndicator, props.Message, props.MessageActions, props.MessageBlocked, props.MessageBouncePrompt, props.MessageDeleted, props.MessageIsThreadReplyInChannelButtonIndicator, props.MessageListNotifications, props.MessageNotification, props.MessageOptions, props.MessageRepliesCountButton, props.MessageStatus, props.MessageSystem, props.MessageTimestamp, props.ModalGallery, props.PinIndicator, props.PollActions, props.PollContent, props.PollCreationDialog, props.PollHeader, props.PollOptionSelector, props.QuotedMessage, props.QuotedMessagePreview, props.QuotedPoll, props.reactionOptions, props.ReactionSelector, props.ReactionsList, props.ReactionsListModal, props.ReminderNotification, props.SendButton, props.SendToChannelCheckbox, props.StartRecordingAudioButton, props.StopAIGenerationButton, props.StreamedMessageText, props.TextareaComposer, props.ThreadHead, props.ThreadHeader, props.ThreadStart, props.Timestamp, props.TypingIndicator, props.UnreadMessagesNotification, props.UnreadMessagesSeparator, props.VirtualMessage]);\n  const typingContextValue = useCreateTypingContext({\n    typing\n  });\n  if (state.error) {\n    return React.createElement(ChannelContainer, null, React.createElement(LoadingErrorIndicator, {\n      error: state.error\n    }));\n  }\n  if (state.loading) {\n    return React.createElement(ChannelContainer, null, React.createElement(LoadingIndicator, null));\n  }\n  if (!channel.watch) {\n    return React.createElement(ChannelContainer, null, React.createElement(\"div\", null, t('Channel Missing')));\n  }\n  return React.createElement(ChannelContainer, {\n    className: windowsEmojiClass\n  }, React.createElement(ChannelStateProvider, {\n    value: channelStateContextValue\n  }, React.createElement(ChannelActionProvider, {\n    value: channelActionContextValue\n  }, React.createElement(WithComponents, {\n    overrides: componentContextValue\n  }, React.createElement(TypingProvider, {\n    value: typingContextValue\n  }, React.createElement(\"div\", {\n    className: clsx(chatContainerClass)\n  }, children))))));\n};\n/**\n * A wrapper component that provides channel data and renders children.\n * The Channel component provides the following contexts:\n * - [ChannelStateContext](https://getstream.io/chat/docs/sdk/react/contexts/channel_state_context/)\n * - [ChannelActionContext](https://getstream.io/chat/docs/sdk/react/contexts/channel_action_context/)\n * - [ComponentContext](https://getstream.io/chat/docs/sdk/react/contexts/component_context/)\n * - [TypingContext](https://getstream.io/chat/docs/sdk/react/contexts/typing_context/)\n */\nexport const Channel = React.memo(UnMemoizedChannel);","map":{"version":3,"names":["React","useCallback","useEffect","useLayoutEffect","useMemo","useReducer","useRef","useState","clsx","debounce","defaultsDeep","throttle","localMessageToNewMessagePayload","initialState","makeChannelReducer","useCreateChannelStateContext","useCreateTypingContext","useEditMessageHandler","useIsMounted","useMentionsHandlers","LoadingErrorIndicator","DefaultLoadingErrorIndicator","LoadingChannel","DefaultLoadingIndicator","ChannelActionProvider","ChannelStateProvider","TypingProvider","useChatContext","useTranslationContext","WithComponents","CHANNEL_CONTAINER_ID","DEFAULT_HIGHLIGHT_DURATION","DEFAULT_INITIAL_CHANNEL_PAGE_SIZE","DEFAULT_JUMP_TO_PAGE_SIZE","DEFAULT_NEXT_CHANNEL_PAGE_SIZE","DEFAULT_THREAD_PAGE_SIZE","hasMoreMessagesProbably","getChatContainerClass","useChannelContainerClasses","useImageFlagEmojisOnWindowsClass","findInMsgSetByDate","findInMsgSetById","makeAddNotifications","useThreadContext","getChannel","getImageAttachmentConfiguration","getVideoAttachmentConfiguration","useSearchFocusedMessage","ChannelContainer","children","className","additionalClassName","props","customClasses","theme","channelClass","chatClass","createElement","id","UnMemoizedChannel","channel","propsChannel","EmptyPlaceholder","LoadingIndicator","contextChannel","channelsQueryState","queryInProgress","error","cid","ChannelInner","key","activeUnreadHandler","channelQueryOptions","propChannelQueryOptions","doDeleteMessageRequest","doMarkReadRequest","doSendMessageRequest","doUpdateMessageRequest","initializeOnMount","markReadOnMount","onMentionsClick","onMentionsHover","skipMessageDataMemoization","messages","limit","client","latestMessageDatesByChannels","mutes","searchController","t","chatContainerClass","chatContainer","windowsEmojiClass","thread","channelConfig","setChannelConfig","getConfig","notifications","setNotifications","notificationTimeouts","channelUnreadUiState","_setChannelUnreadUiState","channelReducer","state","dispatch","hasMore","messagePagination","hasPrev","loading","initialized","jumpToMessageFromSearch","isMounted","originalTitle","lastRead","undefined","online","clearHighlightedMessageTimeoutId","channelCapabilitiesArray","data","own_capabilities","throttledCopyStateFromChannel","type","leading","trailing","setChannelUnreadUiState","markRead","options","updateChannelUiUnreadState","disconnected","read_events","current","Date","markReadResponse","last_read","last_read_message_id","event","unread_messages","document","title","e","console","handleEvent","message","mainChannelUpdated","parent_id","show_in_channel","hidden","muteStatus","muted","unread","countUnread","user","userID","created_at","messageDate","getTime","oldestID","query","id_lt","watchers","prev","last_read_at","first_unread_message_id","errored","done","members","member","userId","user_id","push","config","read","ownReadState","on","notificationTimeoutsRef","off","forEach","clearTimeout","find","m","handleHighlightedMessageChange","highlightDuration","highlightedMessageId","setTimeout","_internalState","getLatestValue","focusedMessage","partialNext","addNotification","loadMoreFinished","loadMore","window","navigator","onLine","oldestMessage","loadingMore","loadingMoreNewer","status","perPage","queryResponse","warn","length","loadMoreNewer","hasNext","newestMessage","newestId","id_gt","hasMoreNewer","jumpToMessage","messageId","messageLimit","loadMessageIntoState","jumpToLatestMessage","jumpToFirstUnreadMessage","queryMessageLimit","lastReadMessageId","firstUnreadMessageId","isInCurrentMessageSet","result","index","target","lastReadTimestamp","lastReadMessageIndex","lastReadMessage","created_at_around","toISOString","firstMessageWithCreationDate","msg","firstMessageTimestamp","targetId","indexOfTarget","findIndex","deleteMessage","Error","deletedMessage","updateMessage","updatedMessage","addMessageSorted","parentId","doSendMessage","localMessage","messageResponse","sendMessage","existingMessage","i","responseTimestamp","updated_at","existingMessageTimestamp","responseIsTheNewest","stringError","JSON","stringify","parsedError","parse","code","includes","upsertReplyLocally","filterErrorMessages","retrySendMessage","removeMessage","openThread","preventDefault","closeThread","loadMoreThreadFinished","threadHasMore","threadMessages","loadMoreThread","threadLoadingMore","oldMessages","threads","oldestMessageId","getReplies","threadHasMoreMessages","newThreadMessages","onMentionsHoverOrClick","editMessage","typing","restState","channelStateContextValue","giphyVersion","imageAttachmentSizeHandler","shouldGenerateVideoThumbnail","videoAttachmentSizeHandler","watcher_count","watcherCount","channelActionContextValue","componentContextValue","Attachment","AttachmentPreviewList","AttachmentSelector","AttachmentSelectorInitiationButtonContents","AudioRecorder","AutocompleteSuggestionItem","AutocompleteSuggestionList","Avatar","BaseImage","CooldownTimer","CustomMessageActionsList","DateSeparator","EditMessageInput","EmojiPicker","emojiSearchIndex","EmptyStateIndicator","FileUploadIcon","GiphyPreviewMessage","HeaderComponent","Input","LinkPreviewList","Message","MessageActions","MessageBlocked","MessageBouncePrompt","MessageDeleted","MessageIsThreadReplyInChannelButtonIndicator","MessageListNotifications","MessageNotification","MessageOptions","MessageRepliesCountButton","MessageStatus","MessageSystem","MessageTimestamp","ModalGallery","PinIndicator","PollActions","PollContent","PollCreationDialog","PollHeader","PollOptionSelector","QuotedMessage","QuotedMessagePreview","QuotedPoll","reactionOptions","ReactionSelector","ReactionsList","ReactionsListModal","ReminderNotification","SendButton","SendToChannelCheckbox","StartRecordingAudioButton","StopAIGenerationButton","StreamedMessageText","TextareaComposer","ThreadHead","ThreadHeader","ThreadStart","Timestamp","TypingIndicator","UnreadMessagesNotification","UnreadMessagesSeparator","VirtualMessage","typingContextValue","watch","value","overrides","Channel","memo"],"sources":["/Users/yashwantmoharil/Documents/Football-Battlegrounds/client/node_modules/stream-chat-react/dist/components/Channel/Channel.js"],"sourcesContent":["import React, { useCallback, useEffect, useLayoutEffect, useMemo, useReducer, useRef, useState, } from 'react';\nimport clsx from 'clsx';\nimport debounce from 'lodash.debounce';\nimport defaultsDeep from 'lodash.defaultsdeep';\nimport throttle from 'lodash.throttle';\nimport { localMessageToNewMessagePayload } from 'stream-chat';\nimport { initialState, makeChannelReducer } from './channelState';\nimport { useCreateChannelStateContext } from './hooks/useCreateChannelStateContext';\nimport { useCreateTypingContext } from './hooks/useCreateTypingContext';\nimport { useEditMessageHandler } from './hooks/useEditMessageHandler';\nimport { useIsMounted } from './hooks/useIsMounted';\nimport { useMentionsHandlers } from './hooks/useMentionsHandlers';\nimport { LoadingErrorIndicator as DefaultLoadingErrorIndicator } from '../Loading';\nimport { LoadingChannel as DefaultLoadingIndicator } from './LoadingChannel';\nimport { ChannelActionProvider, ChannelStateProvider, TypingProvider, useChatContext, useTranslationContext, WithComponents, } from '../../context';\nimport { CHANNEL_CONTAINER_ID } from './constants';\nimport { DEFAULT_HIGHLIGHT_DURATION, DEFAULT_INITIAL_CHANNEL_PAGE_SIZE, DEFAULT_JUMP_TO_PAGE_SIZE, DEFAULT_NEXT_CHANNEL_PAGE_SIZE, DEFAULT_THREAD_PAGE_SIZE, } from '../../constants/limits';\nimport { hasMoreMessagesProbably } from '../MessageList';\nimport { getChatContainerClass, useChannelContainerClasses, useImageFlagEmojisOnWindowsClass, } from './hooks/useChannelContainerClasses';\nimport { findInMsgSetByDate, findInMsgSetById, makeAddNotifications } from './utils';\nimport { useThreadContext } from '../Threads';\nimport { getChannel } from '../../utils';\nimport { getImageAttachmentConfiguration, getVideoAttachmentConfiguration, } from '../Attachment/attachment-sizing';\nimport { useSearchFocusedMessage } from '../../experimental/Search/hooks';\nconst ChannelContainer = ({ children, className: additionalClassName, ...props }) => {\n    const { customClasses, theme } = useChatContext('Channel');\n    const { channelClass, chatClass } = useChannelContainerClasses({\n        customClasses,\n    });\n    const className = clsx(chatClass, theme, channelClass, additionalClassName);\n    return (React.createElement(\"div\", { id: CHANNEL_CONTAINER_ID, ...props, className: className }, children));\n};\nconst UnMemoizedChannel = (props) => {\n    const { channel: propsChannel, EmptyPlaceholder = null, LoadingErrorIndicator, LoadingIndicator = DefaultLoadingIndicator, } = props;\n    const { channel: contextChannel, channelsQueryState } = useChatContext('Channel');\n    const channel = propsChannel || contextChannel;\n    if (channelsQueryState.queryInProgress === 'reload' && LoadingIndicator) {\n        return (React.createElement(ChannelContainer, null,\n            React.createElement(LoadingIndicator, null)));\n    }\n    if (channelsQueryState.error && LoadingErrorIndicator) {\n        return (React.createElement(ChannelContainer, null,\n            React.createElement(LoadingErrorIndicator, { error: channelsQueryState.error })));\n    }\n    if (!channel?.cid) {\n        return React.createElement(ChannelContainer, null, EmptyPlaceholder);\n    }\n    return React.createElement(ChannelInner, { ...props, channel: channel, key: channel.cid });\n};\nconst ChannelInner = (props) => {\n    const { activeUnreadHandler, channel, channelQueryOptions: propChannelQueryOptions, children, doDeleteMessageRequest, doMarkReadRequest, doSendMessageRequest, doUpdateMessageRequest, initializeOnMount = true, LoadingErrorIndicator = DefaultLoadingErrorIndicator, LoadingIndicator = DefaultLoadingIndicator, markReadOnMount = true, onMentionsClick, onMentionsHover, skipMessageDataMemoization, } = props;\n    const channelQueryOptions = useMemo(() => defaultsDeep(propChannelQueryOptions, {\n        messages: { limit: DEFAULT_INITIAL_CHANNEL_PAGE_SIZE },\n    }), [propChannelQueryOptions]);\n    const { client, customClasses, latestMessageDatesByChannels, mutes, searchController } = useChatContext('Channel');\n    const { t } = useTranslationContext('Channel');\n    const chatContainerClass = getChatContainerClass(customClasses?.chatContainer);\n    const windowsEmojiClass = useImageFlagEmojisOnWindowsClass();\n    const thread = useThreadContext();\n    const [channelConfig, setChannelConfig] = useState(channel.getConfig());\n    const [notifications, setNotifications] = useState([]);\n    const notificationTimeouts = useRef([]);\n    const [channelUnreadUiState, _setChannelUnreadUiState] = useState();\n    const channelReducer = useMemo(() => makeChannelReducer(), []);\n    const [state, dispatch] = useReducer(channelReducer, \n    // channel.initialized === false if client.channel().query() was not called, e.g. ChannelList is not used\n    // => Channel will call channel.watch() in useLayoutEffect => state.loading is used to signal the watch() call state\n    {\n        ...initialState,\n        hasMore: channel.state.messagePagination.hasPrev,\n        loading: !channel.initialized,\n        messages: channel.state.messages,\n    });\n    const jumpToMessageFromSearch = useSearchFocusedMessage();\n    const isMounted = useIsMounted();\n    const originalTitle = useRef('');\n    const lastRead = useRef(undefined);\n    const online = useRef(true);\n    const clearHighlightedMessageTimeoutId = useRef(null);\n    const channelCapabilitiesArray = channel.data?.own_capabilities;\n    const throttledCopyStateFromChannel = throttle(() => dispatch({ channel, type: 'copyStateFromChannelOnEvent' }), 500, {\n        leading: true,\n        trailing: true,\n    });\n    const setChannelUnreadUiState = useMemo(() => throttle(_setChannelUnreadUiState, 200, {\n        leading: true,\n        trailing: false,\n    }), []);\n    const markRead = useMemo(() => throttle(async (options) => {\n        const { updateChannelUiUnreadState = true } = options ?? {};\n        if (channel.disconnected || !channelConfig?.read_events) {\n            return;\n        }\n        lastRead.current = new Date();\n        try {\n            if (doMarkReadRequest) {\n                doMarkReadRequest(channel, updateChannelUiUnreadState ? setChannelUnreadUiState : undefined);\n            }\n            else {\n                const markReadResponse = await channel.markRead();\n                if (updateChannelUiUnreadState && markReadResponse) {\n                    _setChannelUnreadUiState({\n                        last_read: lastRead.current,\n                        last_read_message_id: markReadResponse.event.last_read_message_id,\n                        unread_messages: 0,\n                    });\n                }\n            }\n            if (activeUnreadHandler) {\n                activeUnreadHandler(0, originalTitle.current);\n            }\n            else if (originalTitle.current) {\n                document.title = originalTitle.current;\n            }\n        }\n        catch (e) {\n            console.error(t('Failed to mark channel as read'));\n        }\n    }, 500, { leading: true, trailing: false }), [\n        activeUnreadHandler,\n        channel,\n        channelConfig,\n        doMarkReadRequest,\n        setChannelUnreadUiState,\n        t,\n    ]);\n    const handleEvent = async (event) => {\n        if (event.message) {\n            dispatch({\n                channel,\n                message: event.message,\n                type: 'updateThreadOnEvent',\n            });\n        }\n        if (event.type === 'user.watching.start' || event.type === 'user.watching.stop')\n            return;\n        if (event.type === 'typing.start' || event.type === 'typing.stop') {\n            return dispatch({ channel, type: 'setTyping' });\n        }\n        if (event.type === 'connection.changed' && typeof event.online === 'boolean') {\n            online.current = event.online;\n        }\n        if (event.type === 'message.new') {\n            const mainChannelUpdated = !event.message?.parent_id || event.message?.show_in_channel;\n            if (mainChannelUpdated) {\n                if (document.hidden &&\n                    channelConfig?.read_events &&\n                    !channel.muteStatus().muted) {\n                    const unread = channel.countUnread(lastRead.current);\n                    if (activeUnreadHandler) {\n                        activeUnreadHandler(unread, originalTitle.current);\n                    }\n                    else {\n                        document.title = `(${unread}) ${originalTitle.current}`;\n                    }\n                }\n            }\n            if (event.message?.user?.id === client.userID &&\n                event?.message?.created_at &&\n                event?.message?.cid) {\n                const messageDate = new Date(event.message.created_at);\n                const cid = event.message.cid;\n                if (!latestMessageDatesByChannels[cid] ||\n                    latestMessageDatesByChannels[cid].getTime() < messageDate.getTime()) {\n                    latestMessageDatesByChannels[cid] = messageDate;\n                }\n            }\n        }\n        if (event.type === 'user.deleted') {\n            const oldestID = channel.state?.messages?.[0]?.id;\n            /**\n             * As the channel state is not normalized we re-fetch the channel data. Thus, we avoid having to search for user references in the channel state.\n             */\n            // FIXME: we should use channelQueryOptions if they are available\n            await channel.query({\n                messages: { id_lt: oldestID, limit: DEFAULT_NEXT_CHANNEL_PAGE_SIZE },\n                watchers: { limit: DEFAULT_NEXT_CHANNEL_PAGE_SIZE },\n            });\n        }\n        if (event.type === 'notification.mark_unread')\n            _setChannelUnreadUiState((prev) => {\n                if (!(event.last_read_at && event.user))\n                    return prev;\n                return {\n                    first_unread_message_id: event.first_unread_message_id,\n                    last_read: new Date(event.last_read_at),\n                    last_read_message_id: event.last_read_message_id,\n                    unread_messages: event.unread_messages ?? 0,\n                };\n            });\n        if (event.type === 'channel.truncated' && event.cid === channel.cid) {\n            _setChannelUnreadUiState(undefined);\n        }\n        throttledCopyStateFromChannel();\n    };\n    // useLayoutEffect here to prevent spinner. Use Suspense when it is available in stable release\n    useLayoutEffect(() => {\n        let errored = false;\n        let done = false;\n        (async () => {\n            if (!channel.initialized && initializeOnMount) {\n                try {\n                    // if active channel has been set without id, we will create a temporary channel id from its member IDs\n                    // to keep track of the /query request in progress. This is the same approach of generating temporary id\n                    // that the JS client uses to keep track of channel in client.activeChannels\n                    const members = [];\n                    if (!channel.id && channel.data?.members) {\n                        for (const member of channel.data.members) {\n                            let userId;\n                            if (typeof member === 'string') {\n                                userId = member;\n                            }\n                            else if (typeof member === 'object') {\n                                const { user, user_id } = member;\n                                userId = user_id || user?.id;\n                            }\n                            if (userId) {\n                                members.push(userId);\n                            }\n                        }\n                    }\n                    await getChannel({ channel, client, members, options: channelQueryOptions });\n                    const config = channel.getConfig();\n                    setChannelConfig(config);\n                }\n                catch (e) {\n                    dispatch({ error: e, type: 'setError' });\n                    errored = true;\n                }\n            }\n            done = true;\n            originalTitle.current = document.title;\n            if (!errored) {\n                dispatch({\n                    channel,\n                    hasMore: channel.state.messagePagination.hasPrev,\n                    type: 'initStateFromChannel',\n                });\n                if (client.user?.id && channel.state.read[client.user.id]) {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    const { user, ...ownReadState } = channel.state.read[client.user.id];\n                    _setChannelUnreadUiState(ownReadState);\n                }\n                /**\n                 * TODO: maybe pass last_read to the countUnread method to get proper value\n                 * combined with channel.countUnread adjustment (_countMessageAsUnread)\n                 * to allow counting own messages too\n                 *\n                 * const lastRead = channel.state.read[client.userID as string].last_read;\n                 */\n                if (channel.countUnread() > 0 && markReadOnMount)\n                    markRead({ updateChannelUiUnreadState: false });\n                // The more complex sync logic is done in Chat\n                client.on('connection.changed', handleEvent);\n                client.on('connection.recovered', handleEvent);\n                client.on('user.updated', handleEvent);\n                client.on('user.deleted', handleEvent);\n                channel.on(handleEvent);\n            }\n        })();\n        const notificationTimeoutsRef = notificationTimeouts.current;\n        return () => {\n            if (errored || !done)\n                return;\n            channel?.off(handleEvent);\n            client.off('connection.changed', handleEvent);\n            client.off('connection.recovered', handleEvent);\n            client.off('user.deleted', handleEvent);\n            notificationTimeoutsRef.forEach(clearTimeout);\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        channel.cid,\n        channelQueryOptions,\n        doMarkReadRequest,\n        channelConfig?.read_events,\n        initializeOnMount,\n    ]);\n    useEffect(() => {\n        if (!state.thread)\n            return;\n        const message = state.messages?.find((m) => m.id === state.thread?.id);\n        if (message)\n            dispatch({ message, type: 'setThread' });\n    }, [state.messages, state.thread]);\n    const handleHighlightedMessageChange = useCallback(({ highlightDuration, highlightedMessageId, }) => {\n        dispatch({\n            channel,\n            highlightedMessageId,\n            type: 'jumpToMessageFinished',\n        });\n        if (clearHighlightedMessageTimeoutId.current) {\n            clearTimeout(clearHighlightedMessageTimeoutId.current);\n        }\n        clearHighlightedMessageTimeoutId.current = setTimeout(() => {\n            if (searchController._internalState.getLatestValue().focusedMessage) {\n                searchController._internalState.partialNext({ focusedMessage: undefined });\n            }\n            clearHighlightedMessageTimeoutId.current = null;\n            dispatch({ type: 'clearHighlightedMessage' });\n        }, highlightDuration ?? DEFAULT_HIGHLIGHT_DURATION);\n    }, [channel, searchController]);\n    useEffect(() => {\n        if (!jumpToMessageFromSearch?.id)\n            return;\n        handleHighlightedMessageChange({ highlightedMessageId: jumpToMessageFromSearch.id });\n    }, [jumpToMessageFromSearch, handleHighlightedMessageChange]);\n    /** MESSAGE */\n    // Adds a temporary notification to message list, will be removed after 5 seconds\n    const addNotification = useMemo(() => makeAddNotifications(setNotifications, notificationTimeouts.current), []);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const loadMoreFinished = useCallback(debounce((hasMore, messages) => {\n        if (!isMounted.current)\n            return;\n        dispatch({ hasMore, messages, type: 'loadMoreFinished' });\n    }, 2000, { leading: true, trailing: true }), []);\n    const loadMore = async (limit = DEFAULT_NEXT_CHANNEL_PAGE_SIZE) => {\n        if (!online.current ||\n            !window.navigator.onLine ||\n            !channel.state.messagePagination.hasPrev)\n            return 0;\n        // prevent duplicate loading events...\n        const oldestMessage = state?.messages?.[0];\n        if (state.loadingMore ||\n            state.loadingMoreNewer ||\n            oldestMessage?.status !== 'received') {\n            return 0;\n        }\n        dispatch({ loadingMore: true, type: 'setLoadingMore' });\n        const oldestID = oldestMessage?.id;\n        const perPage = limit;\n        let queryResponse;\n        try {\n            queryResponse = await channel.query({\n                messages: { id_lt: oldestID, limit: perPage },\n                watchers: { limit: perPage },\n            });\n        }\n        catch (e) {\n            console.warn('message pagination request failed with error', e);\n            dispatch({ loadingMore: false, type: 'setLoadingMore' });\n            return 0;\n        }\n        loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n        return queryResponse.messages.length;\n    };\n    const loadMoreNewer = async (limit = DEFAULT_NEXT_CHANNEL_PAGE_SIZE) => {\n        if (!online.current ||\n            !window.navigator.onLine ||\n            !channel.state.messagePagination.hasNext)\n            return 0;\n        const newestMessage = state?.messages?.[state?.messages?.length - 1];\n        if (state.loadingMore || state.loadingMoreNewer)\n            return 0;\n        dispatch({ loadingMoreNewer: true, type: 'setLoadingMoreNewer' });\n        const newestId = newestMessage?.id;\n        const perPage = limit;\n        let queryResponse;\n        try {\n            queryResponse = await channel.query({\n                messages: { id_gt: newestId, limit: perPage },\n                watchers: { limit: perPage },\n            });\n        }\n        catch (e) {\n            console.warn('message pagination request failed with error', e);\n            dispatch({ loadingMoreNewer: false, type: 'setLoadingMoreNewer' });\n            return 0;\n        }\n        dispatch({\n            hasMoreNewer: channel.state.messagePagination.hasNext,\n            messages: channel.state.messages,\n            type: 'loadMoreNewerFinished',\n        });\n        return queryResponse.messages.length;\n    };\n    const jumpToMessage = useCallback(async (messageId, messageLimit = DEFAULT_JUMP_TO_PAGE_SIZE, highlightDuration = DEFAULT_HIGHLIGHT_DURATION) => {\n        dispatch({ loadingMore: true, type: 'setLoadingMore' });\n        await channel.state.loadMessageIntoState(messageId, undefined, messageLimit);\n        loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n        handleHighlightedMessageChange({\n            highlightDuration,\n            highlightedMessageId: messageId,\n        });\n    }, [channel, handleHighlightedMessageChange, loadMoreFinished]);\n    const jumpToLatestMessage = useCallback(async () => {\n        await channel.state.loadMessageIntoState('latest');\n        loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n        dispatch({\n            type: 'jumpToLatestMessage',\n        });\n    }, [channel, loadMoreFinished]);\n    const jumpToFirstUnreadMessage = useCallback(async (queryMessageLimit = DEFAULT_JUMP_TO_PAGE_SIZE, highlightDuration = DEFAULT_HIGHLIGHT_DURATION) => {\n        if (!channelUnreadUiState?.unread_messages)\n            return;\n        let lastReadMessageId = channelUnreadUiState?.last_read_message_id;\n        let firstUnreadMessageId = channelUnreadUiState?.first_unread_message_id;\n        let isInCurrentMessageSet = false;\n        if (firstUnreadMessageId) {\n            const result = findInMsgSetById(firstUnreadMessageId, channel.state.messages);\n            isInCurrentMessageSet = result.index !== -1;\n        }\n        else if (lastReadMessageId) {\n            const result = findInMsgSetById(lastReadMessageId, channel.state.messages);\n            isInCurrentMessageSet = !!result.target;\n            firstUnreadMessageId =\n                result.index > -1 ? channel.state.messages[result.index + 1]?.id : undefined;\n        }\n        else {\n            const lastReadTimestamp = channelUnreadUiState.last_read.getTime();\n            const { index: lastReadMessageIndex, target: lastReadMessage } = findInMsgSetByDate(channelUnreadUiState.last_read, channel.state.messages, true);\n            if (lastReadMessage) {\n                firstUnreadMessageId = channel.state.messages[lastReadMessageIndex + 1]?.id;\n                isInCurrentMessageSet = !!firstUnreadMessageId;\n                lastReadMessageId = lastReadMessage.id;\n            }\n            else {\n                dispatch({ loadingMore: true, type: 'setLoadingMore' });\n                let messages;\n                try {\n                    messages = (await channel.query({\n                        messages: {\n                            created_at_around: channelUnreadUiState.last_read.toISOString(),\n                            limit: queryMessageLimit,\n                        },\n                    }, 'new')).messages;\n                }\n                catch (e) {\n                    addNotification(t('Failed to jump to the first unread message'), 'error');\n                    loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n                    return;\n                }\n                const firstMessageWithCreationDate = messages.find((msg) => msg.created_at);\n                if (!firstMessageWithCreationDate) {\n                    addNotification(t('Failed to jump to the first unread message'), 'error');\n                    loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n                    return;\n                }\n                const firstMessageTimestamp = new Date(firstMessageWithCreationDate.created_at).getTime();\n                if (lastReadTimestamp < firstMessageTimestamp) {\n                    // whole channel is unread\n                    firstUnreadMessageId = firstMessageWithCreationDate.id;\n                }\n                else {\n                    const result = findInMsgSetByDate(channelUnreadUiState.last_read, messages);\n                    lastReadMessageId = result.target?.id;\n                }\n                loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n            }\n        }\n        if (!firstUnreadMessageId && !lastReadMessageId) {\n            addNotification(t('Failed to jump to the first unread message'), 'error');\n            return;\n        }\n        if (!isInCurrentMessageSet) {\n            dispatch({ loadingMore: true, type: 'setLoadingMore' });\n            try {\n                const targetId = (firstUnreadMessageId ?? lastReadMessageId);\n                await channel.state.loadMessageIntoState(targetId, undefined, queryMessageLimit);\n                /**\n                 * if the index of the last read message on the page is beyond the half of the page,\n                 * we have arrived to the oldest page of the channel\n                 */\n                const indexOfTarget = channel.state.messages.findIndex((message) => message.id === targetId);\n                loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n                firstUnreadMessageId =\n                    firstUnreadMessageId ?? channel.state.messages[indexOfTarget + 1]?.id;\n            }\n            catch (e) {\n                addNotification(t('Failed to jump to the first unread message'), 'error');\n                loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n                return;\n            }\n        }\n        if (!firstUnreadMessageId) {\n            addNotification(t('Failed to jump to the first unread message'), 'error');\n            return;\n        }\n        if (!channelUnreadUiState.first_unread_message_id)\n            _setChannelUnreadUiState({\n                ...channelUnreadUiState,\n                first_unread_message_id: firstUnreadMessageId,\n                last_read_message_id: lastReadMessageId,\n            });\n        handleHighlightedMessageChange({\n            highlightDuration,\n            highlightedMessageId: firstUnreadMessageId,\n        });\n    }, [\n        addNotification,\n        channel,\n        handleHighlightedMessageChange,\n        loadMoreFinished,\n        t,\n        channelUnreadUiState,\n    ]);\n    const deleteMessage = useCallback(async (message) => {\n        if (!message?.id) {\n            throw new Error('Cannot delete a message - missing message ID.');\n        }\n        let deletedMessage;\n        if (doDeleteMessageRequest) {\n            deletedMessage = await doDeleteMessageRequest(message);\n        }\n        else {\n            const result = await client.deleteMessage(message.id);\n            deletedMessage = result.message;\n        }\n        return deletedMessage;\n    }, [client, doDeleteMessageRequest]);\n    const updateMessage = (updatedMessage) => {\n        // add the message to the local channel state\n        channel.state.addMessageSorted(updatedMessage, true);\n        dispatch({\n            channel,\n            parentId: state.thread && updatedMessage.parent_id,\n            type: 'copyMessagesFromChannel',\n        });\n    };\n    const doSendMessage = async ({ localMessage, message, options, }) => {\n        try {\n            let messageResponse;\n            if (doSendMessageRequest) {\n                messageResponse = await doSendMessageRequest(channel, message, options);\n            }\n            else {\n                messageResponse = await channel.sendMessage(message, options);\n            }\n            let existingMessage = undefined;\n            for (let i = channel.state.messages.length - 1; i >= 0; i--) {\n                const msg = channel.state.messages[i];\n                if (msg.id && msg.id === message.id) {\n                    existingMessage = msg;\n                    break;\n                }\n            }\n            const responseTimestamp = new Date(messageResponse?.message?.updated_at || 0).getTime();\n            const existingMessageTimestamp = existingMessage?.updated_at?.getTime() || 0;\n            const responseIsTheNewest = responseTimestamp > existingMessageTimestamp;\n            // Replace the message payload after send is completed\n            // We need to check for the newest message payload, because on slow network, the response can arrive later than WS events message.new, message.updated.\n            // Always override existing message in status \"sending\"\n            if (messageResponse?.message &&\n                (responseIsTheNewest || existingMessage?.status === 'sending')) {\n                updateMessage({\n                    ...messageResponse.message,\n                    status: 'received',\n                });\n            }\n        }\n        catch (error) {\n            // error response isn't usable so needs to be stringified then parsed\n            const stringError = JSON.stringify(error);\n            const parsedError = (stringError ? JSON.parse(stringError) : {});\n            // Handle the case where the message already exists\n            // (typically, when retrying to send a message).\n            // If the message already exists, we can assume it was sent successfully,\n            // so we update the message status to \"received\".\n            // Right now, the only way to check this error is by checking\n            // the combination of the error code and the error description,\n            // since there is no special error code for duplicate messages.\n            if (parsedError.code === 4 &&\n                error instanceof Error &&\n                error.message.includes('already exists')) {\n                updateMessage({\n                    ...localMessage,\n                    status: 'received',\n                });\n            }\n            else {\n                updateMessage({\n                    ...localMessage,\n                    error: parsedError,\n                    status: 'failed',\n                });\n                thread?.upsertReplyLocally({\n                    message: {\n                        ...localMessage,\n                        error: parsedError,\n                        status: 'failed',\n                    },\n                });\n            }\n        }\n    };\n    const sendMessage = async ({ localMessage, message, options, }) => {\n        channel.state.filterErrorMessages();\n        thread?.upsertReplyLocally({\n            message: localMessage,\n        });\n        updateMessage(localMessage);\n        await doSendMessage({ localMessage, message, options });\n    };\n    const retrySendMessage = async (localMessage) => {\n        updateMessage({\n            ...localMessage,\n            error: undefined,\n            status: 'sending',\n        });\n        await doSendMessage({\n            localMessage,\n            message: localMessageToNewMessagePayload(localMessage),\n        });\n    };\n    const removeMessage = (message) => {\n        channel.state.removeMessage(message);\n        dispatch({\n            channel,\n            parentId: state.thread && message.parent_id,\n            type: 'copyMessagesFromChannel',\n        });\n    };\n    /** THREAD */\n    const openThread = (message, event) => {\n        event?.preventDefault();\n        dispatch({ channel, message, type: 'openThread' });\n    };\n    const closeThread = (event) => {\n        event?.preventDefault();\n        dispatch({ type: 'closeThread' });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const loadMoreThreadFinished = useCallback(debounce((threadHasMore, threadMessages) => {\n        dispatch({\n            threadHasMore,\n            threadMessages,\n            type: 'loadMoreThreadFinished',\n        });\n    }, 2000, { leading: true, trailing: true }), []);\n    const loadMoreThread = async (limit = DEFAULT_THREAD_PAGE_SIZE) => {\n        // FIXME: should prevent loading more, if state.thread.reply_count === channel.state.threads[parentID].length\n        if (state.threadLoadingMore || !state.thread || !state.threadHasMore)\n            return;\n        dispatch({ type: 'startLoadingThread' });\n        const parentId = state.thread.id;\n        if (!parentId) {\n            return dispatch({ type: 'closeThread' });\n        }\n        const oldMessages = channel.state.threads[parentId] || [];\n        const oldestMessageId = oldMessages[0]?.id;\n        try {\n            const queryResponse = await channel.getReplies(parentId, {\n                id_lt: oldestMessageId,\n                limit,\n            });\n            const threadHasMoreMessages = hasMoreMessagesProbably(queryResponse.messages.length, limit);\n            const newThreadMessages = channel.state.threads[parentId] || [];\n            // next set loadingMore to false so we can start asking for more data\n            loadMoreThreadFinished(threadHasMoreMessages, newThreadMessages);\n        }\n        catch (e) {\n            loadMoreThreadFinished(false, oldMessages);\n        }\n    };\n    const onMentionsHoverOrClick = useMentionsHandlers(onMentionsHover, onMentionsClick);\n    const editMessage = useEditMessageHandler(doUpdateMessageRequest);\n    const { typing, ...restState } = state;\n    const channelStateContextValue = useCreateChannelStateContext({\n        ...restState,\n        channel,\n        channelCapabilitiesArray,\n        channelConfig,\n        channelUnreadUiState,\n        giphyVersion: props.giphyVersion || 'fixed_height',\n        imageAttachmentSizeHandler: props.imageAttachmentSizeHandler || getImageAttachmentConfiguration,\n        mutes,\n        notifications,\n        shouldGenerateVideoThumbnail: props.shouldGenerateVideoThumbnail || true,\n        videoAttachmentSizeHandler: props.videoAttachmentSizeHandler || getVideoAttachmentConfiguration,\n        watcher_count: state.watcherCount,\n    });\n    const channelActionContextValue = useMemo(() => ({\n        addNotification,\n        closeThread,\n        deleteMessage,\n        dispatch,\n        editMessage,\n        jumpToFirstUnreadMessage,\n        jumpToLatestMessage,\n        jumpToMessage,\n        loadMore,\n        loadMoreNewer,\n        loadMoreThread,\n        markRead,\n        onMentionsClick: onMentionsHoverOrClick,\n        onMentionsHover: onMentionsHoverOrClick,\n        openThread,\n        removeMessage,\n        retrySendMessage,\n        sendMessage,\n        setChannelUnreadUiState,\n        skipMessageDataMemoization,\n        updateMessage,\n    }), \n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        channel.cid,\n        deleteMessage,\n        loadMore,\n        loadMoreNewer,\n        markRead,\n        jumpToFirstUnreadMessage,\n        jumpToMessage,\n        jumpToLatestMessage,\n        setChannelUnreadUiState,\n    ]);\n    const componentContextValue = useMemo(() => ({\n        Attachment: props.Attachment,\n        AttachmentPreviewList: props.AttachmentPreviewList,\n        AttachmentSelector: props.AttachmentSelector,\n        AttachmentSelectorInitiationButtonContents: props.AttachmentSelectorInitiationButtonContents,\n        AudioRecorder: props.AudioRecorder,\n        AutocompleteSuggestionItem: props.AutocompleteSuggestionItem,\n        AutocompleteSuggestionList: props.AutocompleteSuggestionList,\n        Avatar: props.Avatar,\n        BaseImage: props.BaseImage,\n        CooldownTimer: props.CooldownTimer,\n        CustomMessageActionsList: props.CustomMessageActionsList,\n        DateSeparator: props.DateSeparator,\n        EditMessageInput: props.EditMessageInput,\n        EmojiPicker: props.EmojiPicker,\n        emojiSearchIndex: props.emojiSearchIndex,\n        EmptyStateIndicator: props.EmptyStateIndicator,\n        FileUploadIcon: props.FileUploadIcon,\n        GiphyPreviewMessage: props.GiphyPreviewMessage,\n        HeaderComponent: props.HeaderComponent,\n        Input: props.Input,\n        LinkPreviewList: props.LinkPreviewList,\n        LoadingIndicator: props.LoadingIndicator,\n        Message: props.Message,\n        MessageActions: props.MessageActions,\n        MessageBlocked: props.MessageBlocked,\n        MessageBouncePrompt: props.MessageBouncePrompt,\n        MessageDeleted: props.MessageDeleted,\n        MessageIsThreadReplyInChannelButtonIndicator: props.MessageIsThreadReplyInChannelButtonIndicator,\n        MessageListNotifications: props.MessageListNotifications,\n        MessageNotification: props.MessageNotification,\n        MessageOptions: props.MessageOptions,\n        MessageRepliesCountButton: props.MessageRepliesCountButton,\n        MessageStatus: props.MessageStatus,\n        MessageSystem: props.MessageSystem,\n        MessageTimestamp: props.MessageTimestamp,\n        ModalGallery: props.ModalGallery,\n        PinIndicator: props.PinIndicator,\n        PollActions: props.PollActions,\n        PollContent: props.PollContent,\n        PollCreationDialog: props.PollCreationDialog,\n        PollHeader: props.PollHeader,\n        PollOptionSelector: props.PollOptionSelector,\n        QuotedMessage: props.QuotedMessage,\n        QuotedMessagePreview: props.QuotedMessagePreview,\n        QuotedPoll: props.QuotedPoll,\n        reactionOptions: props.reactionOptions,\n        ReactionSelector: props.ReactionSelector,\n        ReactionsList: props.ReactionsList,\n        ReactionsListModal: props.ReactionsListModal,\n        ReminderNotification: props.ReminderNotification,\n        SendButton: props.SendButton,\n        SendToChannelCheckbox: props.SendToChannelCheckbox,\n        StartRecordingAudioButton: props.StartRecordingAudioButton,\n        StopAIGenerationButton: props.StopAIGenerationButton,\n        StreamedMessageText: props.StreamedMessageText,\n        TextareaComposer: props.TextareaComposer,\n        ThreadHead: props.ThreadHead,\n        ThreadHeader: props.ThreadHeader,\n        ThreadStart: props.ThreadStart,\n        Timestamp: props.Timestamp,\n        TypingIndicator: props.TypingIndicator,\n        UnreadMessagesNotification: props.UnreadMessagesNotification,\n        UnreadMessagesSeparator: props.UnreadMessagesSeparator,\n        VirtualMessage: props.VirtualMessage,\n    }), [\n        props.Attachment,\n        props.AttachmentPreviewList,\n        props.AttachmentSelector,\n        props.AttachmentSelectorInitiationButtonContents,\n        props.AudioRecorder,\n        props.AutocompleteSuggestionItem,\n        props.AutocompleteSuggestionList,\n        props.Avatar,\n        props.BaseImage,\n        props.CooldownTimer,\n        props.CustomMessageActionsList,\n        props.DateSeparator,\n        props.EditMessageInput,\n        props.EmojiPicker,\n        props.emojiSearchIndex,\n        props.EmptyStateIndicator,\n        props.FileUploadIcon,\n        props.GiphyPreviewMessage,\n        props.HeaderComponent,\n        props.Input,\n        props.LinkPreviewList,\n        props.LoadingIndicator,\n        props.Message,\n        props.MessageActions,\n        props.MessageBlocked,\n        props.MessageBouncePrompt,\n        props.MessageDeleted,\n        props.MessageIsThreadReplyInChannelButtonIndicator,\n        props.MessageListNotifications,\n        props.MessageNotification,\n        props.MessageOptions,\n        props.MessageRepliesCountButton,\n        props.MessageStatus,\n        props.MessageSystem,\n        props.MessageTimestamp,\n        props.ModalGallery,\n        props.PinIndicator,\n        props.PollActions,\n        props.PollContent,\n        props.PollCreationDialog,\n        props.PollHeader,\n        props.PollOptionSelector,\n        props.QuotedMessage,\n        props.QuotedMessagePreview,\n        props.QuotedPoll,\n        props.reactionOptions,\n        props.ReactionSelector,\n        props.ReactionsList,\n        props.ReactionsListModal,\n        props.ReminderNotification,\n        props.SendButton,\n        props.SendToChannelCheckbox,\n        props.StartRecordingAudioButton,\n        props.StopAIGenerationButton,\n        props.StreamedMessageText,\n        props.TextareaComposer,\n        props.ThreadHead,\n        props.ThreadHeader,\n        props.ThreadStart,\n        props.Timestamp,\n        props.TypingIndicator,\n        props.UnreadMessagesNotification,\n        props.UnreadMessagesSeparator,\n        props.VirtualMessage,\n    ]);\n    const typingContextValue = useCreateTypingContext({\n        typing,\n    });\n    if (state.error) {\n        return (React.createElement(ChannelContainer, null,\n            React.createElement(LoadingErrorIndicator, { error: state.error })));\n    }\n    if (state.loading) {\n        return (React.createElement(ChannelContainer, null,\n            React.createElement(LoadingIndicator, null)));\n    }\n    if (!channel.watch) {\n        return (React.createElement(ChannelContainer, null,\n            React.createElement(\"div\", null, t('Channel Missing'))));\n    }\n    return (React.createElement(ChannelContainer, { className: windowsEmojiClass },\n        React.createElement(ChannelStateProvider, { value: channelStateContextValue },\n            React.createElement(ChannelActionProvider, { value: channelActionContextValue },\n                React.createElement(WithComponents, { overrides: componentContextValue },\n                    React.createElement(TypingProvider, { value: typingContextValue },\n                        React.createElement(\"div\", { className: clsx(chatContainerClass) }, children)))))));\n};\n/**\n * A wrapper component that provides channel data and renders children.\n * The Channel component provides the following contexts:\n * - [ChannelStateContext](https://getstream.io/chat/docs/sdk/react/contexts/channel_state_context/)\n * - [ChannelActionContext](https://getstream.io/chat/docs/sdk/react/contexts/channel_action_context/)\n * - [ComponentContext](https://getstream.io/chat/docs/sdk/react/contexts/component_context/)\n * - [TypingContext](https://getstream.io/chat/docs/sdk/react/contexts/typing_context/)\n */\nexport const Channel = React.memo(UnMemoizedChannel);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}