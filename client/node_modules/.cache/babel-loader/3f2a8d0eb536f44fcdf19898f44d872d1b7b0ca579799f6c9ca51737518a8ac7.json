{"ast":null,"code":"import Dayjs, { isDayjs } from 'dayjs';\nexport const notValidDateWarning = 'MessageTimestamp was called without a message, or message has invalid created_at date.';\nexport const noParsingFunctionWarning = 'MessageTimestamp was called but there is no datetime parsing function available';\nexport const isNumberOrString = output => typeof output === 'string' || typeof output === 'number';\nexport const isDayOrMoment = output => !!output?.isSame;\nexport const isDate = output => output !== null && typeof output === 'object' && typeof output.getTime === 'function';\nexport function getDateString({\n  calendar,\n  calendarFormats,\n  format,\n  formatDate,\n  messageCreatedAt,\n  t,\n  tDateTimeParser,\n  timestampTranslationKey\n}) {\n  if (!messageCreatedAt || typeof messageCreatedAt === 'string' && !Date.parse(messageCreatedAt)) {\n    console.warn(notValidDateWarning);\n    return null;\n  }\n  if (typeof formatDate === 'function') {\n    return formatDate(new Date(messageCreatedAt));\n  }\n  if (t && timestampTranslationKey) {\n    const options = {};\n    if (typeof calendar !== 'undefined' && calendar !== null) options.calendar = calendar;\n    if (typeof calendarFormats !== 'undefined' && calendarFormats !== null) options.calendarFormats = calendarFormats;\n    if (typeof format !== 'undefined' && format !== null) options.format = format;\n    const translatedTimestamp = t(timestampTranslationKey, {\n      ...options,\n      timestamp: new Date(messageCreatedAt)\n    });\n    const translationKeyFound = timestampTranslationKey !== translatedTimestamp;\n    if (translationKeyFound) return translatedTimestamp;\n  }\n  if (!tDateTimeParser) {\n    console.warn(noParsingFunctionWarning);\n    return null;\n  }\n  const parsedTime = tDateTimeParser(messageCreatedAt);\n  if (isDayOrMoment(parsedTime)) {\n    /**\n     * parsedTime.calendar is guaranteed on the type but is only\n     * available when a user calls dayjs.extend(calendar)\n     */\n    return calendar && parsedTime.calendar ? parsedTime.calendar(undefined, calendarFormats || undefined) : parsedTime.format(format || undefined);\n  }\n  if (isDate(parsedTime)) {\n    return parsedTime.toDateString();\n  }\n  if (isNumberOrString(parsedTime)) {\n    return parsedTime;\n  }\n  return null;\n}\nexport const predefinedFormatters = {\n  durationFormatter: streamI18n => (value, _, {\n    format,\n    withSuffix\n  }) => {\n    if (format && isDayjs(streamI18n.DateTimeParser)) {\n      return streamI18n.DateTimeParser.duration(value).format(format);\n    }\n    return streamI18n.DateTimeParser.duration(value).humanize(!!withSuffix);\n  },\n  timestampFormatter: streamI18n => (value, _, {\n    calendarFormats,\n    ...options\n  }) => {\n    let parsedCalendarFormats;\n    try {\n      if (!options.calendar) {\n        parsedCalendarFormats = {};\n      } else if (typeof calendarFormats === 'string') {\n        parsedCalendarFormats = JSON.parse(calendarFormats);\n      } else if (typeof calendarFormats === 'object') {\n        parsedCalendarFormats = calendarFormats;\n      }\n    } catch (e) {\n      console.error('[TIMESTAMP FORMATTER]', e);\n    }\n    const result = getDateString({\n      ...options,\n      calendarFormats: parsedCalendarFormats,\n      messageCreatedAt: value,\n      tDateTimeParser: streamI18n.tDateTimeParser\n    });\n    if (!result || typeof result === 'number') {\n      return JSON.stringify(value);\n    }\n    return result;\n  }\n};\nexport const defaultTranslatorFunction = key => key;\nexport const defaultDateTimeParser = input => Dayjs(input);\nexport const isLanguageSupported = language => {\n  const translations = ['de', 'en', 'es', 'fr', 'hi', 'it', 'ja', 'ko', 'nl', 'pt', 'ru', 'tr'];\n  return translations.some(translation => language === translation);\n};","map":{"version":3,"names":["Dayjs","isDayjs","notValidDateWarning","noParsingFunctionWarning","isNumberOrString","output","isDayOrMoment","isSame","isDate","getTime","getDateString","calendar","calendarFormats","format","formatDate","messageCreatedAt","t","tDateTimeParser","timestampTranslationKey","Date","parse","console","warn","options","translatedTimestamp","timestamp","translationKeyFound","parsedTime","undefined","toDateString","predefinedFormatters","durationFormatter","streamI18n","value","_","withSuffix","DateTimeParser","duration","humanize","timestampFormatter","parsedCalendarFormats","JSON","e","error","result","stringify","defaultTranslatorFunction","key","defaultDateTimeParser","input","isLanguageSupported","language","translations","some","translation"],"sources":["/Users/yashwantmoharil/Desktop/football-battlegrounds/client/node_modules/stream-chat-react/dist/i18n/utils.js"],"sourcesContent":["import Dayjs, { isDayjs } from 'dayjs';\nexport const notValidDateWarning = 'MessageTimestamp was called without a message, or message has invalid created_at date.';\nexport const noParsingFunctionWarning = 'MessageTimestamp was called but there is no datetime parsing function available';\nexport const isNumberOrString = (output) => typeof output === 'string' || typeof output === 'number';\nexport const isDayOrMoment = (output) => !!output?.isSame;\nexport const isDate = (output) => output !== null &&\n    typeof output === 'object' &&\n    typeof output.getTime === 'function';\nexport function getDateString({ calendar, calendarFormats, format, formatDate, messageCreatedAt, t, tDateTimeParser, timestampTranslationKey, }) {\n    if (!messageCreatedAt ||\n        (typeof messageCreatedAt === 'string' && !Date.parse(messageCreatedAt))) {\n        console.warn(notValidDateWarning);\n        return null;\n    }\n    if (typeof formatDate === 'function') {\n        return formatDate(new Date(messageCreatedAt));\n    }\n    if (t && timestampTranslationKey) {\n        const options = {};\n        if (typeof calendar !== 'undefined' && calendar !== null)\n            options.calendar = calendar;\n        if (typeof calendarFormats !== 'undefined' && calendarFormats !== null)\n            options.calendarFormats = calendarFormats;\n        if (typeof format !== 'undefined' && format !== null)\n            options.format = format;\n        const translatedTimestamp = t(timestampTranslationKey, {\n            ...options,\n            timestamp: new Date(messageCreatedAt),\n        });\n        const translationKeyFound = timestampTranslationKey !== translatedTimestamp;\n        if (translationKeyFound)\n            return translatedTimestamp;\n    }\n    if (!tDateTimeParser) {\n        console.warn(noParsingFunctionWarning);\n        return null;\n    }\n    const parsedTime = tDateTimeParser(messageCreatedAt);\n    if (isDayOrMoment(parsedTime)) {\n        /**\n         * parsedTime.calendar is guaranteed on the type but is only\n         * available when a user calls dayjs.extend(calendar)\n         */\n        return calendar && parsedTime.calendar\n            ? parsedTime.calendar(undefined, calendarFormats || undefined)\n            : parsedTime.format(format || undefined);\n    }\n    if (isDate(parsedTime)) {\n        return parsedTime.toDateString();\n    }\n    if (isNumberOrString(parsedTime)) {\n        return parsedTime;\n    }\n    return null;\n}\nexport const predefinedFormatters = {\n    durationFormatter: (streamI18n) => (value, _, { format, withSuffix }) => {\n        if (format && isDayjs(streamI18n.DateTimeParser)) {\n            return streamI18n.DateTimeParser.duration(value).format(format);\n        }\n        return streamI18n.DateTimeParser.duration(value).humanize(!!withSuffix);\n    },\n    timestampFormatter: (streamI18n) => (value, _, { calendarFormats, ...options }) => {\n        let parsedCalendarFormats;\n        try {\n            if (!options.calendar) {\n                parsedCalendarFormats = {};\n            }\n            else if (typeof calendarFormats === 'string') {\n                parsedCalendarFormats = JSON.parse(calendarFormats);\n            }\n            else if (typeof calendarFormats === 'object') {\n                parsedCalendarFormats = calendarFormats;\n            }\n        }\n        catch (e) {\n            console.error('[TIMESTAMP FORMATTER]', e);\n        }\n        const result = getDateString({\n            ...options,\n            calendarFormats: parsedCalendarFormats,\n            messageCreatedAt: value,\n            tDateTimeParser: streamI18n.tDateTimeParser,\n        });\n        if (!result || typeof result === 'number') {\n            return JSON.stringify(value);\n        }\n        return result;\n    },\n};\nexport const defaultTranslatorFunction = ((key) => key);\nexport const defaultDateTimeParser = (input) => Dayjs(input);\nexport const isLanguageSupported = (language) => {\n    const translations = [\n        'de',\n        'en',\n        'es',\n        'fr',\n        'hi',\n        'it',\n        'ja',\n        'ko',\n        'nl',\n        'pt',\n        'ru',\n        'tr',\n    ];\n    return translations.some((translation) => language === translation);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}